#include<iostream>
#include<fstream>
#include<direct.h>
#include<string.h>
#include<Windows.h>
#include<cstdlib>
#include<conio.h>
#include<ctime>
#include<iomanip> 

#define _WIN32_WINNT 0x0500

using namespace std;

bool fromConsole = false;
short int parseRule[128][16] = { {16,32,16,2,32,16,32,2,32,2,2,4,32,2,2,32},
{32,2,32,8,16,4,16,32,32,4,4,2,32,4,32,4},
{16,8,16,2,32,4,32,32,8,2,32,8,8,8,32,16},
{32,4,16,8,32,8,8,32,32,8,4,32,4,16,4,16},
{32,32,4,16,16,8,8,16,8,16,4,32,8,32,8,16},
{2,16,16,16,32,8,32,4,32,4,2,8,16,32,32,4},
{8,32,8,16,16,2,16,16,32,16,32,8,16,32,2,4},
{4,32,32,4,16,8,32,8,32,2,16,32,4,16,2,16},
{2,16,32,32,2,16,2,16,2,32,32,2,32,4,2,32},
{8,8,16,32,2,2,16,2,32,32,16,8,32,16,32,2},
{2,16,8,2,4,32,8,32,32,8,8,32,8,32,16,16},
{32,4,32,8,32,32,2,16,32,8,2,4,8,4,8,32},
{4,16,32,2,32,32,2,16,4,16,32,32,8,16,4,8},
{2,32,16,8,4,32,32,32,8,4,8,32,2,4,32,8},
{8,4,4,16,16,32,16,32,4,2,32,16,32,2,32,8},
{32,8,32,16,4,8,16,2,32,16,4,4,32,2,16,32},
{2,16,32,32,8,32,16,8,4,4,4,32,2,16,32,16},
{2,2,32,8,32,8,8,32,16,32,16,16,8,32,4,8},
{16,32,2,32,2,16,32,8,16,8,16,2,2,32,8,32},
{4,32,16,32,8,2,32,16,16,16,8,2,4,32,32,4},
{32,2,32,8,2,32,4,4,16,8,16,32,32,16,16,4},
{32,16,32,4,16,4,8,4,16,2,16,8,2,32,32,32},
{32,8,16,2,16,8,32,16,16,2,8,32,32,2,32,2},
{8,4,2,8,8,32,8,32,32,2,16,32,16,8,16,32},
{16,2,4,32,8,32,2,16,16,4,32,16,32,8,32,4},
{32,32,16,32,2,8,16,16,4,32,32,16,4,8,4,2},
{8,16,2,32,32,8,4,8,32,16,32,8,2,32,16,8},
{16,32,8,16,2,16,16,4,8,16,2,8,32,16,32,32},
{32,4,2,4,2,32,16,32,32,2,32,8,2,32,8,16},
{16,4,16,2,16,32,32,4,4,32,8,32,2,8,16,32},
{2,16,2,32,16,32,4,16,32,16,2,32,16,4,32,2},
{16,32,32,4,8,4,32,32,4,16,2,16,8,32,2,16},
{16,32,16,8,8,8,4,8,32,16,8,16,32,4,16,32},
{8,32,8,4,32,4,32,16,2,32,16,2,32,4,16,16},
{32,16,8,4,32,4,32,16,32,2,32,4,16,16,8,2},
{8,4,32,32,4,16,4,2,16,8,32,32,16,32,2,16},
{16,4,8,2,32,16,8,8,16,32,16,16,32,16,32,2},
{16,32,32,16,2,16,2,32,32,16,32,4,2,2,4,16},
{2,32,32,2,2,4,32,16,32,16,4,8,32,8,32,2},
{32,16,32,2,2,8,2,8,16,4,2,32,32,32,4,32},
{2,16,32,16,32,16,16,2,4,32,16,32,32,2,4,2},
{8,8,4,16,32,32,2,32,32,8,32,8,4,32,4,2},
{8,16,2,16,2,32,32,32,2,16,2,16,32,8,8,32},
{32,2,16,32,16,4,32,8,32,4,32,16,4,2,8,16},
{8,32,8,32,8,16,8,4,8,32,16,32,4,8,32,8},
{16,32,32,4,8,32,2,8,16,32,16,32,8,2,8,8},
{32,2,4,32,2,2,16,32,8,16,32,4,32,32,2,8},
{32,16,8,4,4,2,4,32,8,32,16,2,16,32,32,16},
{32,32,4,4,32,4,8,2,4,32,4,16,32,16,2,32},
{32,8,2,32,32,16,2,16,32,8,8,2,32,2,16,16},
{32,16,4,32,8,32,8,4,32,8,32,4,2,2,32,8},
{32,2,16,2,32,16,2,16,8,32,32,8,16,2,8,32},
{32,2,32,16,32,16,32,32,4,16,4,8,2,4,16,8},
{32,32,4,16,4,4,32,4,16,4,8,16,32,32,16,4},
{4,8,32,8,32,16,4,8,32,32,32,2,8,4,32,2},
{8,32,32,8,2,16,32,16,8,32,8,4,8,2,16,32},
{16,2,32,8,32,16,16,4,16,2,8,32,16,8,32,16},
{8,32,2,32,4,32,2,2,32,4,16,16,8,32,2,32},
{32,8,16,32,4,8,32,32,2,32,8,16,8,16,2,8},
{4,32,8,32,4,2,32,32,8,16,32,16,16,4,16,2},
{32,2,2,16,32,4,32,8,4,2,16,32,8,2,32,32},
{32,8,2,16,16,16,32,4,32,32,4,32,8,16,4,2},
{4,32,4,32,32,4,8,8,8,2,32,2,8,32,16,32},
{32,4,2,4,8,32,4,8,8,32,8,32,32,32,16,2},
{32,16,16,8,32,2,16,2,2,32,2,32,8,8,16,32},
{4,32,8,32,8,32,8,16,32,4,8,32,32,2,4,2},
{16,8,32,16,32,32,4,32,2,4,2,32,8,2,2,32},
{32,32,4,32,8,32,4,32,16,2,4,32,4,4,2,16},
{16,8,32,32,32,2,16,32,16,32,4,16,4,4,8,2},
{2,2,32,4,8,16,8,32,8,8,32,8,32,16,32,16},
{16,8,32,16,32,2,8,4,32,8,32,16,16,16,2,16},
{32,16,4,16,32,8,2,8,2,16,8,16,16,16,32,32},
{2,32,32,8,32,8,16,8,16,16,32,2,16,2,2,32},
{2,8,16,16,8,32,2,8,16,2,32,32,32,16,2,32},
{32,8,32,8,16,16,8,16,4,4,8,32,16,32,16,8},
{4,32,32,4,16,32,16,32,8,8,16,2,2,32,16,4},
{32,4,32,8,16,32,32,32,16,4,2,16,2,8,4,16},
{2,32,16,4,2,32,8,32,16,32,32,4,4,16,16,8},
{16,4,32,32,2,4,16,4,32,16,16,2,8,32,32,8},
{32,16,4,2,16,2,32,8,32,8,4,32,16,4,16,32},
{32,2,4,2,4,32,16,32,32,8,16,16,4,16,8,32},
{2,16,8,4,8,16,16,32,2,4,32,32,16,32,4,32},
{4,2,8,16,16,32,4,32,2,32,32,4,8,16,32,16},
{8,8,32,16,8,4,16,32,8,16,8,32,2,32,32,2},
{2,8,32,32,2,2,32,4,8,32,2,16,32,32,4,16},
{8,32,32,16,4,2,32,2,4,32,2,32,2,8,32,16},
{32,16,8,2,2,16,32,2,16,16,32,16,2,32,16,16},
{16,8,32,8,4,8,2,32,8,32,32,32,4,2,32,4},
{2,32,32,16,16,16,4,32,8,32,4,2,16,8,4,32},
{16,32,16,32,32,8,16,8,16,8,4,4,8,16,32,8},
{4,4,16,16,32,16,32,32,8,32,2,4,2,32,8,16},
{16,32,32,32,4,4,16,2,4,2,8,32,4,32,4,32},
{4,16,4,32,32,32,16,2,32,32,4,8,16,2,8,16},
{16,2,4,16,32,8,4,32,32,32,8,32,2,16,16,4},
{2,8,8,32,16,32,8,2,16,8,4,16,32,32,32,8},
{4,32,2,4,32,2,4,8,16,4,4,32,16,32,32,32},
{8,2,32,32,16,8,32,4,4,2,32,8,32,8,4,32},
{16,16,8,32,4,32,32,8,32,16,16,2,32,4,2,4},
{16,4,4,16,32,2,32,16,16,32,8,8,32,4,2,32},
{4,32,2,8,2,8,16,32,8,32,16,32,32,8,8,16},
{4,8,16,2,16,2,4,16,32,8,32,16,32,32,4,32},
{4,16,8,32,16,4,8,32,4,32,16,32,16,2,2,32},
{4,2,16,32,2,32,2,32,4,16,16,16,2,32,32,16},
{16,32,16,4,32,32,4,2,2,8,32,2,32,32,8,2},
{32,32,8,2,32,2,2,32,4,4,32,2,32,16,8,16},
{32,16,4,32,8,16,4,2,32,2,16,16,32,8,4,32},
{4,32,4,4,2,8,32,32,2,4,32,2,32,2,32,32},
{16,4,8,32,32,8,16,16,8,8,16,32,16,32,8,4},
{32,16,16,8,16,4,2,32,16,16,32,2,16,32,8,8},
{16,32,16,4,16,16,8,16,32,32,4,16,8,4,32,4},
{32,32,16,32,4,16,16,32,2,16,4,32,2,8,8,4},
{32,2,32,32,4,32,16,8,2,32,16,4,16,8,4,16},
{8,2,32,16,4,16,32,16,2,32,32,16,4,32,8,4},
{32,8,16,8,16,32,32,2,8,8,32,4,16,8,2,32},
{32,32,16,16,32,2,8,32,8,4,16,16,4,2,32,4},
{8,2,16,2,16,32,16,8,16,16,4,8,32,32,16,32},
{4,16,2,32,32,4,2,4,8,32,16,4,32,32,32,4},
{2,8,8,2,32,8,32,32,4,8,16,16,32,8,16,32},
{32,16,32,16,8,4,8,16,32,4,8,16,8,8,32,16},
{2,8,32,32,32,4,2,32,8,4,16,32,16,4,16,16},
{32,32,8,2,4,32,32,8,16,8,32,8,4,2,32,4},
{32,4,16,4,8,16,32,4,32,16,16,8,4,16,16,32},
{16,4,4,32,16,8,32,8,2,16,2,4,32,32,32,16},
{32,4,2,2,8,16,16,32,16,32,32,4,16,4,32,8},
{16,16,8,8,16,4,32,16,8,32,32,16,32,8,4,8},
{16,32,8,16,32,16,32,4,32,4,32,2,4,8,16,2},
{16,32,2,8,32,32,8,16,4,32,2,32,4,32,2,2},
{ 2,4,32,4,32,32,32,4,4,16,4,32,16,32,8,2 } };
short int renewRule[4][520] = { {192,10,192,79,55,177,225,233,182,148,92,77,74,216,208,112,167,176,180,188,29,130,235,88,199,69,152,170,6,46,51,26,45,139,221,25,126,239,240,98,86,143,219,128,164,236,45,145,159,178,239,73,185,224,55,58,206,42,250,82,162,156,34,165,138,127,224,108,105,128,68,78,222,15,11,223,188,6,184,103,187,139,230,228,109,55,220,82,115,120,98,41,240,51,211,40,62,174,116,81,224,174,4,53,184,220,148,113,122,153,121,97,2,64,148,33,205,1,40,28,246,119,56,216,61,111,43,177,224,63,207,203,191,89,157,75,190,31,63,199,107,249,79,250,225,165,98,189,236,207,69,51,109,226,134,67,0,29,54,75,221,233,238,18,252,106,16,255,125,84,79,137,70,0,114,239,238,191,84,41,218,110,48,30,165,74,27,23,197,6,210,116,108,27,182,158,173,96,21,60,224,218,171,170,71,213,105,166,242,51,117,77,223,5,113,71,102,88,0,62,212,81,134,148,87,125,48,85,26,98,53,106,176,90,91,16,182,161,188,137,180,172,202,17,69,188,145,20,120,180,60,158,117,39,219,19,100,182,99,32,138,153,246,241,181,123,101,165,219,139,244,255,254,208,93,94,82,188,23,239,162,5,215,33,240,176,88,89,92,111,88,232,71,44,227,58,183,230,211,79,253,188,152,111,150,71,53,26,80,45,139,63,173,243,218,174,140,19,133,206,6,79,21,147,151,68,129,171,126,66,173,248,102,91,48,67,69,186,90,47,133,55,118,107,98,40,76,44,147,121,234,219,44,255,164,10,195,9,90,173,209,56,249,135,92,145,68,226,211,209,213,131,58,0,94,221,134,73,53,133,75,9,16,230,148,38,13,54,18,162,245,169,122,112,193,228,40,134,93,180,8,51,173,0,182,179,206,252,228,1,158,160,253,236,126,89,7,109,86,254,206,56,218,5,63,145,12,247,18,97,2,33,172,137,234,141,67,118,75,48,67,245,142,101,240,73,188,154,77,124,137,73,61,242,146,43,233,68,227,168,97,75,188,145,134,122,149,17,39,113,95,225,106,208,13,188,110,73,83,19,46,250,173,1,169,249,164,129,64,48,77,223,95,107,18,108,95,175,180,118,171,206,145,119,34,56,35,141,189,20,202,42,114,143,203,13,88,116,152,113},
{8,134,183,213,92,85,42,27,237,187,241,25,53,88,253,142,76,243,199,160,12,18,145,21,116,199,238,197,74,204,132,79,4,210,17,12,233,23,172,65,116,55,78,153,249,68,144,210,138,24,182,182,28,234,237,77,230,32,209,81,10,100,50,226,119,250,24,123,14,81,4,37,4,216,121,234,135,18,187,141,164,237,215,120,104,80,227,246,69,243,135,162,184,115,189,32,41,166,212,10,19,44,187,45,100,70,124,246,39,235,7,39,96,25,49,206,55,106,252,120,89,231,25,162,156,32,171,112,226,125,78,162,63,207,88,195,94,42,95,163,32,247,251,8,135,69,204,161,211,96,191,59,234,165,142,55,253,148,134,60,105,39,141,41,219,98,99,78,184,44,40,219,188,93,31,152,225,24,177,215,130,91,181,168,192,212,238,75,37,247,213,235,135,77,153,137,47,15,101,54,59,243,225,133,65,70,251,64,53,59,231,90,141,131,100,37,162,29,66,197,90,112,33,229,4,151,123,168,131,252,229,226,175,40,145,137,248,217,24,102,77,85,118,16,60,255,86,27,90,40,145,141,229,39,241,145,168,172,58,112,31,81,107,188,220,114,65,207,41,63,253,116,239,15,103,227,214,248,19,243,174,156,227,139,14,69,205,89,58,53,222,199,74,55,127,43,137,122,248,62,28,159,50,208,228,17,193,186,165,149,33,19,103,34,64,167,28,242,61,164,132,217,112,151,78,214,170,151,128,232,190,192,24,34,64,228,243,2,140,124,239,255,10,229,77,97,177,201,89,85,202,219,76,65,247,199,113,85,115,104,135,99,155,60,103,240,174,22,230,139,209,19,253,93,86,207,39,2,61,217,11,151,251,100,91,20,123,63,252,220,99,7,103,147,152,155,79,48,4,208,132,83,151,102,23,216,139,59,191,172,237,191,123,223,89,168,121,251,5,231,55,149,0,218,232,33,188,195,25,11,203,121,148,3,230,93,132,152,51,144,219,8,200,99,241,86,107,15,109,158,155,167,105,166,213,74,209,181,16,157,12,168,138,120,223,66,198,224,142,196,213,54,68,189,214,173,180,36,185,2,1,164,72,103,219,55,103,192,236,246,154,17,114,48,201,55,45,185,64,215,123,132,250,149,194,116,31,134,14,112,203,231,251,182,17,15,214,113,64,162},
{223,129,80,114,79,30,235,131,178,114,191,224,83,167,21,59,107,36,142,64,69,25,104,203,160,87,253,88,85,102,140,187,57,209,60,17,69,197,94,246,244,218,243,248,237,49,110,76,226,191,187,192,184,232,127,241,232,80,162,190,37,238,11,252,63,98,170,107,71,136,188,233,244,77,230,69,193,243,24,104,110,236,112,219,233,69,76,209,166,110,238,215,16,249,45,183,217,161,106,156,143,140,198,120,113,205,146,163,128,45,8,197,217,43,56,245,65,65,68,34,2,105,208,178,246,224,181,106,225,42,245,142,3,86,244,73,238,131,229,78,150,163,130,192,167,127,0,80,27,252,66,165,11,156,77,0,197,71,252,32,32,76,244,99,12,163,219,47,109,117,197,144,42,221,239,34,128,241,176,50,157,252,172,32,106,14,75,7,168,183,106,160,62,15,80,100,209,249,227,241,150,169,27,175,100,100,184,179,14,135,48,228,239,203,236,92,198,199,179,17,197,183,103,180,228,123,239,217,123,227,116,89,16,41,208,244,109,191,67,59,246,75,104,174,58,241,104,33,200,208,110,100,68,207,91,34,186,153,186,10,49,230,246,45,132,253,202,167,109,118,250,130,227,69,65,215,166,244,138,54,24,48,99,72,78,135,174,179,103,112,153,62,28,140,209,54,153,43,243,16,139,18,68,79,123,124,161,169,90,94,185,101,93,239,121,7,11,104,200,47,148,8,117,191,100,92,109,60,248,189,50,119,240,26,136,108,102,248,114,106,127,182,92,116,63,22,154,232,162,249,17,94,232,106,52,211,48,222,51,7,72,186,110,35,196,22,48,159,77,193,154,99,60,133,221,44,104,172,173,50,59,194,242,8,12,157,192,195,168,155,137,94,50,43,145,93,46,143,163,177,216,224,3,220,186,82,163,85,125,185,153,46,0,76,209,244,167,169,255,215,246,26,216,10,94,23,130,109,86,12,73,106,174,92,147,28,32,165,22,183,41,70,72,36,23,30,23,235,98,151,219,86,63,227,137,212,115,134,41,155,101,21,138,145,120,61,52,109,151,6,158,25,18,89,161,91,168,193,45,181,229,110,59,138,174,127,2,129,26,129,110,47,131,50,206,240,221,139,205,21,71,254,163,69,224,253,140,29,220,187,121,26,215,54,6,185,104,117,173,220},
{63,253,194,40,197,181,252,145,133,186,89,117,41,34,102,189,66,72,228,185,47,30,201,19,65,196,136,6,29,89,146,203,97,17,29,84,138,135,36,61,21,85,175,0,228,227,84,104,228,124,254,72,237,167,237,108,233,180,254,208,57,149,45,16,84,239,88,32,177,113,61,232,101,231,35,20,132,221,129,123,15,60,170,113,27,142,141,121,45,27,231,174,6,103,183,97,192,251,243,4,26,104,121,70,17,138,72,128,176,10,240,80,40,38,71,131,35,181,94,57,86,101,179,67,85,72,168,208,172,143,52,73,43,149,217,121,129,31,214,241,13,226,157,171,240,69,135,237,103,105,199,112,88,102,157,194,42,216,204,233,218,155,77,73,75,210,69,200,222,46,53,47,67,109,112,211,143,32,211,118,142,178,176,104,90,166,11,241,44,32,9,244,115,167,165,204,35,41,165,122,80,63,204,2,251,179,82,18,44,64,145,229,65,152,1,103,133,172,102,154,4,39,72,56,158,59,164,154,91,161,225,216,254,219,5,50,221,189,41,174,239,43,43,3,39,36,162,182,0,0,23,131,90,245,114,254,132,224,178,122,154,66,225,42,17,137,71,134,144,146,223,240,1,107,7,152,233,93,123,157,244,42,132,117,213,147,109,142,76,29,55,53,136,21,142,184,176,210,251,199,189,58,90,32,138,136,143,108,46,76,117,99,137,178,23,55,29,8,35,48,31,123,155,147,206,33,206,201,4,61,135,189,11,190,132,134,177,8,41,70,159,247,118,82,230,33,55,147,219,92,122,44,37,129,70,92,20,111,138,166,53,82,84,48,35,37,67,106,159,117,63,239,227,104,103,176,52,255,75,79,183,152,92,201,133,183,161,88,1,5,171,152,106,153,202,232,172,119,129,19,124,86,56,48,163,167,49,198,154,210,189,52,88,195,176,80,104,165,18,79,62,237,23,229,203,155,81,172,79,188,37,202,111,52,124,207,135,186,186,220,65,36,244,10,103,229,94,9,245,212,2,8,115,47,184,213,129,223,82,70,180,253,23,215,160,150,115,148,54,171,236,58,81,124,88,153,139,7,77,60,85,203,218,76,71,209,116,178,180,237,51,124,130,66,63,130,56,4,133,73,89,130,174,39,241,99,81,168,109,47,103,49,175,18,0,227,98,221,53,194} };
char reserveKey[4][524] = { {43,89,14,46,19,-74,97,88,26,127,-53,-73,-47,-80,-115,-38,-111,110,121,57,82,98,34,61,36,-89,15,-4,-101,82,-54,-54,23,119,-55,98,93,-107,84,-13,1,70,106,76,5,24,-43,-29,40,-126,97,25,97,56,-30,86,-26,-23,-112,-27,-47,-85,85,70,44,18,24,37,-117,58,-92,-21,-2,78,53,126,106,68,-56,-120,33,92,-78,9,-43,30,-77,126,-78,-27,100,-53,-81,54,86,71,114,-43,54,-108,89,-115,-71,37,1,110,75,24,-58,2,-97,-72,67,70,46,-18,-98,-28,64,-41,71,125,-117,-48,-19,102,-118,59,-62,-42,5,47,-22,73,-127,-6,24,18,12,22,70,-17,25,95,-8,-96,82,99,-112,51,54,-12,8,36,72,75,41,9,49,1,-103,63,41,-88,-61,0,107,-70,123,54,-99,39,118,6,117,84,81,-34,104,53,-30,2,73,-34,-4,98,-95,-60,98,-69,-115,112,-104,-52,11,-24,76,19,-21,-91,5,-19,-23,-79,73,-118,123,104,0,8,-8,99,47,31,48,17,-47,-44,-30,125,124,113,103,-47,-124,80,85,12,84,59,126,-14,-79,-35,-100,77,20,-101,-13,93,-37,55,81,38,-11,-83,36,123,-42,-86,27,-25,64,-15,-118,97,-58,-82,-7,96,12,-124,29,-54,-93,67,-89,71,20,-87,45,-22,-34,27,-123,102,28,-95,101,2,0,-88,-99,-88,-37,86,-58,80,106,98,43,107,9,77,72,-50,-95,105,-65,31,102,120,-8,60,-89,121,107,64,102,-59,53,125,-28,-89,2,28,-36,-114,-18,67,-95,119,-30,98,68,76,-122,13,21,52,94,-119,-116,-94,-84,112,-6,38,28,-122,2,-73,91,57,65,20,34,-48,58,93,-37,-44,-63,-113,93,-79,-101,6,-33,14,-117,-104,64,111,110,-109,-95,-103,-67,15,-10,-65,125,105,-95,-11,-11,109,30,-121,-54,88,-24,-112,-62,-33,-104,120,-48,88,-33,-54,54,35,103,-19,-44,-116,-75,64,-4,50,-100,34,77,-97,-41,-27,6,71,-39,-72,-53,-20,-12,-9,66,-78,90,-117,8,114,24,49,109,-17,-105,84,112,-94,-54,94,-27,34,116,-98,-57,118,-50,-77,25,-53,-7,-114,93,-42,-29,-128,-127,99,42,113,-52,-41,29,-92,-88,50,91,-88,81,-66,70,98,-54,-121,40,-44,40,89,95,-7,124,-75,-20,102,3,-86,31,-110,-30,100,85,102,-118,97,-121,-7,7,-80,0,-96,-18,28,18,-79,-92,-98,38,-101,15,11,99,72,30,86,95,-45,-90,-50,15,11,-14,59,-22,-41,-110,-72,115,122,-55,-60,-107,44},
{41,98,13,42,-18,43,-57,-8,43,-23,122,68,-126,2,106,2,127,-32,-127,-92,-18,-39,-75,31,55,-48,119,47,-68,-125,-2,0,71,116,-2,25,-117,-40,11,-52,54,15,39,-112,36,-126,-54,-122,34,-7,89,24,100,-57,-36,-26,11,59,-4,117,106,-17,111,-42,104,-77,-127,50,31,58,94,121,33,-42,43,38,-118,91,-77,-66,62,-12,51,26,116,15,109,-117,-4,-104,-73,-12,-36,64,21,110,41,-15,1,121,-66,-74,-89,106,-56,72,10,-109,36,-37,-46,71,-100,-111,-25,59,-116,11,118,-5,102,3,-8,94,-97,-9,5,-89,12,-65,-33,-31,48,27,34,-113,126,18,-35,46,23,59,38,64,-7,-73,-25,81,-50,123,-35,42,17,57,-94,40,110,-3,40,97,-119,-41,25,-94,-18,-105,-37,92,-121,5,-46,-115,-73,19,2,-51,-118,112,52,-13,12,1,91,12,-67,30,44,13,-68,30,-67,6,-114,-108,-74,56,-89,-64,-71,73,-101,21,44,14,19,96,-114,26,-13,104,-29,-126,80,-93,-4,26,-99,56,34,10,-83,8,-40,-3,121,117,-39,-33,-67,-114,111,-48,104,-37,-67,-48,-24,3,-58,81,-51,-13,32,-100,87,-52,35,-46,88,-78,34,98,-99,78,-37,-73,-97,32,-74,29,-57,93,10,114,-113,22,113,-72,45,67,-5,35,41,8,40,-89,-113,-55,-127,-73,9,-36,96,27,23,-24,3,-90,-57,-37,-107,57,-112,111,103,51,-91,-91,68,110,-123,72,80,-59,-122,-67,-52,78,-97,-49,34,78,-66,-88,36,0,-35,52,90,66,-81,-109,82,-69,22,102,-71,-102,52,-115,-57,93,-50,-97,60,-17,-36,-45,118,123,95,-14,97,-96,124,47,-56,29,102,109,-59,4,6,-41,-34,119,11,-53,10,-78,-74,-10,33,-74,-104,-69,-117,-33,-108,-85,-99,97,-37,-82,-17,-69,58,-88,60,-58,90,57,-8,-23,-17,-36,61,125,-42,13,48,13,32,-80,-120,109,39,-15,94,-42,14,75,81,-12,85,-32,-46,-80,96,-12,-125,18,-105,32,-2,-8,5,-7,7,-92,-110,-8,93,59,-44,-87,-52,59,112,-6,39,23,25,-35,52,-17,-65,76,98,-105,80,24,53,-40,-81,-118,-75,53,80,44,104,-119,-115,69,19,87,-83,-10,-50,-102,32,116,-82,106,-4,47,-5,78,-61,23,75,7,-36,55,124,58,103,75,78,-85,82,18,32,11,-54,9,-89,-5,118,83,4,77,22,-33,18,30,-14,50,114,82,-66,75,15,-97,-53,31,-103,23,-71,20,78,105,0,111,-123,75,0,66,-57,-57,-14,26,117,87},
{39,93,14,45,11,-127,7,-25,-78,-2,121,3,102,-68,125,109,-53,-99,46,-66,120,52,-64,90,15,101,76,-65,125,-104,-76,22,-103,5,-31,46,-111,123,5,-51,-52,92,0,-127,-55,4,-16,18,8,37,-8,59,57,59,-85,-19,-58,-108,-59,60,-29,-97,19,-76,-65,-12,38,85,10,-52,-41,90,-41,30,-18,64,-81,-24,-43,108,-49,47,-77,88,-50,124,49,-54,70,-11,-41,-102,35,-79,-2,40,83,11,109,-54,122,71,123,-56,-81,-75,66,5,-19,40,-69,0,50,117,-43,97,110,84,-32,-122,-35,-48,-40,115,82,29,105,17,3,-3,67,10,-124,47,-121,73,105,85,-14,-47,51,120,10,11,18,-105,-30,50,29,72,-35,-11,5,126,-24,16,99,87,16,-53,-83,38,-119,81,113,-119,110,-92,79,63,93,52,117,-109,47,105,123,-109,-2,125,99,-31,-83,-85,38,-39,-109,105,13,-42,47,-64,65,90,-43,-6,74,88,-57,-76,111,-25,-66,-113,-82,-86,-71,-118,61,-101,-77,74,-53,-99,-9,-54,114,-15,76,75,13,-122,42,-25,-18,41,36,-72,31,-108,-50,106,-100,120,59,24,93,97,-34,115,107,-105,107,-14,-26,107,10,-113,-35,-118,-25,-43,37,67,-122,-48,-86,-48,-47,-112,125,38,97,72,-20,80,-37,88,-122,-48,-13,-68,92,-96,120,39,71,49,-43,-60,-96,-100,31,-6,24,96,108,-99,47,71,34,-38,126,110,3,101,57,-2,-119,-83,46,4,118,19,43,6,13,105,-122,-56,-18,-52,54,-47,16,-124,46,33,43,5,-9,-77,58,-62,58,64,-39,109,-95,-54,22,-54,-33,123,6,-75,54,74,-61,16,-67,126,-113,-100,-33,-117,60,14,54,-62,-76,-49,71,116,-90,74,78,97,-78,-97,6,46,-77,51,42,42,-25,-8,34,-93,23,-59,16,-110,-110,-68,34,-38,-119,-123,0,114,-97,94,-94,25,83,70,93,-114,-7,78,-114,-44,-8,67,-97,121,-127,69,86,124,105,11,29,59,123,-52,67,10,63,-80,95,80,-93,-96,82,-26,-109,-34,-116,118,68,-30,-93,-95,-30,40,87,69,-33,-105,125,-13,126,48,15,33,109,-5,81,18,12,39,46,116,33,-98,-30,84,-99,-110,5,58,72,86,-12,42,80,-30,108,92,-77,127,5,91,125,-36,-111,98,50,16,-102,-92,-126,83,73,-24,24,-15,-89,16,-115,-81,116,-14,-32,57,116,55,4,-56,-5,4,-48,34,-94,-69,116,12,-46,-115,53,98,53,-93,22,118,-113,-87,-81,-56,51,122,95,-36,13,-86,12,-82,-41,70,38,-123},
{44,89,14,47,-25,-127,-111,26,-99,22,69,74,-68,-7,103,70,70,-6,-36,-79,-96,52,-111,66,-21,-78,-31,31,-56,36,89,49,-95,-118,99,-109,-70,-91,-24,-28,-125,-123,-37,23,117,126,56,-108,-123,-23,-121,62,99,118,-54,-84,-107,100,7,57,41,126,-73,-92,11,-82,-38,-9,58,102,-119,-23,-24,-41,29,95,-60,37,-21,94,110,10,-97,-122,102,-88,-91,93,-15,-19,73,-116,55,-57,101,-39,-101,25,80,-6,34,45,96,-120,-38,-120,57,55,13,101,58,-104,64,54,-78,-122,80,-13,-57,1,24,46,48,-98,-128,-9,23,-41,-35,70,104,-55,-123,-31,76,-66,-8,-41,-111,-106,6,-68,-48,-36,82,-115,126,-96,29,6,-53,106,-78,-60,119,-38,-29,14,114,73,-15,122,124,-9,73,115,35,-80,-9,72,61,90,58,42,80,-26,-114,118,118,26,-99,13,-66,15,0,24,-111,-114,24,-118,19,124,11,-71,-102,125,39,-43,-86,-90,32,-96,-122,-61,8,-80,77,-103,-18,24,-62,-102,116,-65,-94,9,-47,81,33,-20,37,116,-122,101,-16,-49,-124,54,44,-2,-96,-117,76,108,107,117,-93,87,-48,119,8,94,63,50,26,-43,-19,-107,14,92,127,13,103,-45,-46,-101,-2,-54,-81,97,-68,105,52,112,-17,123,30,-8,17,44,89,42,126,121,123,81,-39,-116,11,-105,-80,106,-71,-25,-112,56,107,87,-94,-5,-60,33,12,-109,-118,-120,12,-34,7,59,-83,61,86,-2,-119,93,-71,-52,-45,36,87,20,-59,114,-114,92,-93,-78,62,121,-31,-8,-94,126,37,-127,-71,44,-70,112,63,-118,39,29,45,-25,120,67,-14,94,123,97,38,-75,-16,43,117,-84,-5,-41,-88,-123,81,30,-39,99,-27,-73,80,-42,-89,73,21,-99,1,-27,56,119,44,39,-47,-93,-104,12,-69,-55,103,-108,20,127,-60,66,-3,32,30,7,-81,33,127,-62,75,41,19,74,12,11,17,49,-62,-24,-103,-57,-75,29,72,-15,82,67,-12,109,-56,95,-2,15,6,22,6,-104,-97,-24,119,-80,-95,-26,82,-108,90,-48,-126,-97,14,24,-54,-87,51,-79,119,-29,-104,-74,-10,59,35,-70,127,-32,-6,86,-34,-11,-44,-45,40,19,57,118,-53,17,-23,-50,-44,85,80,-124,91,-107,-112,42,-20,53,49,-35,95,-57,-25,100,111,-37,12,113,13,12,-79,-36,64,2,-18,102,-4,105,-39,-56,89,-8,-79,85,-2,-104,75,51,63,64,-80,-104,-75,-96,16,17,74,-86,-37,33,13,-121,76,99,-65,24,19,-29,118,14,124,-25} };
char hidstr[4][32] = { {105,100,100,113,100, 0}, //iddqd
{98,111,98,111,116,97,97,112,105,101,114,100,117,116,99,104,101,105,97,0}, //bob
{103,105,77,77,101,82,101,83,101,82,118,101,0}, //gimme
{72,101,121,85,110,99,108,101,65,99,105,100,33,0} }; //hey

void startup(const HWND cHwnd, const HANDLE hOutput, const CONSOLE_SCREEN_BUFFER_INFO bufferInfo) noexcept 
{


	//Setting a font 
	CONSOLE_FONT_INFOEX cfi;
	cfi.cbSize = sizeof(cfi);
	cfi.nFont = 0;
	cfi.dwFontSize.X = 8;                   // Width of each character in the font
	cfi.dwFontSize.Y = 12;                  // Height
	cfi.FontFamily = FF_DONTCARE;
	cfi.FontWeight = FW_NORMAL;
	wcscpy_s(cfi.FaceName, L"Lucida Console"); // Choose your font
	SetCurrentConsoleFontEx(hOutput, FALSE, &cfi);

	//Setting the window size
	RECT r;
	GetWindowRect(cHwnd, &r);
	MoveWindow(cHwnd, r.left, r.top, 960, 600, TRUE);

	//Corelating buffer to the size
	COORD size = {512 , 12000};
	SetConsoleScreenBufferSize(hOutput, size);

	CONSOLE_CURSOR_INFO cursorInfo;
	GetConsoleCursorInfo(hOutput, &cursorInfo);
	//cursorInfo.bVisible = false;
	cursorInfo.dwSize = 1;
	SetConsoleCursorInfo(hOutput, &cursorInfo);

	/*
	DWORD prev_mode;
	GetConsoleMode(hInput, &prev_mode);
	SetConsoleMode(hInput, prev_mode & ~ENABLE_QUICK_EDIT_MODE);
	*/
	SetWindowLong(cHwnd, GWL_STYLE, GetWindowLong(cHwnd, GWL_STYLE) & ~WS_MAXIMIZEBOX & ~WS_SIZEBOX);

	SetConsoleTitle(TEXT("FireFez 1.0"));
}

int charSum(const char s[], const int start, const int len, const int size) noexcept 
{
	int sum = 0, i;
	for (i=start;i<start + len && i < size;i++)
		sum += static_cast<int>(s[i]);
	return sum;
}
int sign(const int n) noexcept 
{
	if (n >= 0)
		return 1;
	return -1;
}
int digitCnt(unsigned long long int n) noexcept 
{
	int c = 1;
	while (n>9)
	{
		c++;
		n /= 10;
	}
	return c;
}
void getDate(int &d, int &y) noexcept 
{
	struct tm newtime;
	__int64 ltime;
	_time64(&ltime);
	_gmtime64_s(&newtime, &ltime);

	d = newtime.tm_yday + 1;
	y = newtime.tm_year + 1;
}
long long int getFileSize(const char filename[])noexcept
{
	struct _stat64 stat_buf;
	const int rc = _stat64(filename, &stat_buf);
	return rc == 0 ? stat_buf.st_size : 0;
}

void clearScreen(HANDLE hOutput, CONSOLE_SCREEN_BUFFER_INFO bufferInfo) noexcept
{
	COORD topLeft = { 0, 0 };
	DWORD written;

	GetConsoleScreenBufferInfo(hOutput, &bufferInfo);
	FillConsoleOutputCharacterA(hOutput, ' ', static_cast<DWORD>(bufferInfo.dwSize.X * bufferInfo.dwSize.Y), topLeft, &written);
	FillConsoleOutputAttribute(hOutput, FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE, static_cast<DWORD>(bufferInfo.dwSize.X * bufferInfo.dwSize.Y), topLeft, &written);
	//SetConsoleCursorPosition(hOutput, topLeft);
}
void drawText(const char text[], const short int x, const short int y, const int fg, const int bg, const HANDLE hOutput)
{
	COORD pos; pos.X = x; pos.Y = y;
	SetConsoleCursorPosition(hOutput, pos);

	SetConsoleTextAttribute(hOutput, static_cast<WORD>(fg + bg * 16));
	cout << text;
	SetConsoleTextAttribute(hOutput, 15);
}
void drawInt(unsigned long long int text,const short int x, const short int y, const int fg,const int bg,const HANDLE hOutput)
{
	COORD pos; pos.X = x; pos.Y = y;
	SetConsoleCursorPosition(hOutput, pos);

	SetConsoleTextAttribute(hOutput, static_cast<WORD>(fg + bg * 16));
	cout << text << '\n';
	SetConsoleTextAttribute(hOutput, 15);
}

void drawTitle(const short int x,const short int y,const HANDLE hOutput)
{
	drawText(" °±²Û                                                  Û²±°", x, y, 7, 0, hOutput);
	drawText("°", x, y, 8, 0, hOutput); drawText("ÜÜß", x + 26, y, 15, 0, hOutput); drawText("Ü", x + 29, y, 7, 15, hOutput); drawText("°", x + 59, y, 8, 0, hOutput);
	drawText(" °±²Û             ßßßßßßß     Û    ÜÜÜÜÜ     ßßßßßß    Û²±°", x, y + 1, 7, 0, hOutput);
	drawText("°", x, y + 1, 8, 0, hOutput); drawText("ßÛßßßßßßßß", x + 8, y + 1, 15, 0, hOutput); drawText("ß", x + 25, y + 1, 7, 8, hOutput); drawText("°", x + 26, y + 1, 4, 0, hOutput); drawText("±", x + 27, y + 1, 6, 4, hOutput); drawText("²°", x + 28, y + 1, 4, 0, hOutput); drawText("ÜÜ", x + 33, y + 1, 15, 0, hOutput); drawText("Ûßßßß", x + 40, y + 1, 15, 0, hOutput); drawText("ß", x + 51, y + 1, 7, 8, hOutput); drawText("°", x + 59, y + 1, 8, 0, hOutput);
	drawText("  °±²Û                                                Û²±°", x, y + 2, 7, 0, hOutput);
	drawText("°", x + 1, y + 2, 8, 0, hOutput); drawText("Û", x + 10, y + 2, 15, 0, hOutput); drawText("°", x + 17, y + 2, 4, 0, hOutput); drawText("°", x + 20, y + 2, 8, 0, hOutput); drawText("Üß ß", x + 23, y + 2, 8, 0, hOutput); drawText("Ü", x + 27, y + 2, 8, 6, hOutput); drawText("ßß", x + 28, y + 2, 8, 0, hOutput); drawText("Û", x + 32, y + 2, 15, 0, hOutput); drawText("°   °", x + 33, y + 2, 4, 0, hOutput); drawText("Û", x + 40, y + 2, 15, 0, hOutput); drawText("°   °", x + 41, y + 2, 4, 0, hOutput); drawText("°", x + 47, y + 2, 8, 0, hOutput); drawText("Üß", x + 49, y + 2, 8, 0, hOutput); drawText("°", x + 58, y + 2, 8, 0, hOutput);
	drawText("   °±²Û                    ÜÜ         ßÜ             Û²±°", x, y + 3, 7, 0, hOutput);
	drawText("°", x + 2, y + 3, 8, 0, hOutput); drawText("Û", x + 10, y + 3, 15, 0, hOutput); drawText("°", x + 12, y + 3, 4, 0, hOutput); drawText("°Ûßßßßßßß", x + 14, y + 3, 8, 0, hOutput); drawText("ß", x + 29, y + 3, 7, 8, hOutput); drawText("Û", x + 32, y + 3, 15, 0, hOutput); drawText("°Ûßß", x + 34, y + 3, 8, 0, hOutput); drawText("Û", x + 40, y + 3, 15, 0, hOutput); drawText("°Ûßßßß", x + 43, y + 3, 8, 0, hOutput); drawText("°", x + 57, y + 3, 8, 0, hOutput);
	drawText("   °±²Û        Û         Ûß     Û  Û   ÛÛ           Û²±°", x, y + 4, 7, 0, hOutput);
	drawText("°", x + 2, y + 4, 8, 0, hOutput); drawText("Û", x + 10, y + 4, 15, 0, hOutput); drawText("°  °", x + 11, y + 4, 4, 0, hOutput); drawText("°", x + 28, y + 4, 4, 0, hOutput); drawText("Û", x + 29, y + 4, 8, 0, hOutput); drawText("°", x + 34, y + 4, 4, 0, hOutput); drawText("°", x + 42, y + 4, 4, 0, hOutput); drawText("ßÜÜÜ", x + 44, y + 4, 8, 0, hOutput); drawText("°", x + 56, y + 4, 8, 0, hOutput);
	drawText("   °±²Û        ßßßß      Û      Û  ßßßß Û           Û²±°", x, y + 5, 7, 0, hOutput);
	drawText("°", x + 2, y + 5, 8, 0, hOutput); drawText("Û", x + 10, y + 5, 15, 0, hOutput); drawText("°°", x + 11, y + 5, 4, 0, hOutput); drawText("Û", x + 19, y + 5, 8, 0, hOutput); drawText("°", x + 26, y + 5, 8, 0, hOutput); drawText("°", x + 28, y + 5, 4, 0, hOutput); drawText("Û", x + 29, y + 5, 8, 0, hOutput); drawText("°", x + 33, y + 5, 4, 0, hOutput); drawText("°", x + 39, y + 5, 8, 0, hOutput); drawText("°±°°", x + 41, y + 5, 4, 0, hOutput); drawText("° Û", x + 46, y + 5, 8, 0, hOutput); drawText("°", x + 56, y + 5, 8, 0, hOutput);
	drawText("   °±²Û                  Û      Û      ßÛ           Û²±°", x, y + 6, 7, 0, hOutput);
	drawText("°", x + 2, y + 6, 8, 0, hOutput); drawText("Û", x + 10, y + 6, 15, 0, hOutput); drawText("°±°  °", x + 11, y + 6, 4, 0, hOutput); drawText("Üß", x + 17, y + 6, 8, 0, hOutput); drawText("°±", x + 27, y + 6, 4, 0, hOutput); drawText("Û", x + 29, y + 6, 8, 0, hOutput); drawText("°°°±±", x + 34, y + 6, 4, 0, hOutput); drawText("°±±", x + 41, y + 6, 4, 0, hOutput); drawText("ÜÜÜÜß", x + 44, y + 6, 8, 0, hOutput); drawText("°", x + 56, y + 6, 8, 0, hOutput);
	drawText("   °±²Û                                             Û²±°", x, y + 7, 7, 0, hOutput);
	drawText("°", x + 2, y + 7, 8, 0, hOutput); drawText("Ü", x + 10, y + 7, 8, 7, hOutput); drawText("²±±°", x + 11, y + 7, 4, 0, hOutput); drawText("±ß        Û", x + 15, y + 7, 8, 0, hOutput); drawText("°±±", x + 26, y + 7, 4, 0, hOutput); drawText("Û  ²", x + 29, y + 7, 8, 0, hOutput); drawText("±±°", x + 33, y + 7, 4, 0, hOutput); drawText("Ü", x + 36, y + 7, 8, 7, hOutput); drawText("Ü", x + 37, y + 7, 8, 0, hOutput); drawText("²±", x + 38, y + 7, 4, 0, hOutput); drawText("²", x + 40, y + 7, 8, 0, hOutput); drawText("±²²", x + 41, y + 7, 4, 0, hOutput); drawText("±", x + 44, y + 7, 8, 0, hOutput); drawText("°", x + 56, y + 7, 8, 0, hOutput);
	drawText("   °±²Û              ßßßßßß            ßßßßßß        Û²±°", x, y + 8, 7, 0, hOutput);
	drawText("°", x + 2, y + 8, 8, 0, hOutput); drawText("Ü", x + 10, y + 8, 7, 15, hOutput); drawText("Ûßßßßßßßßß", x + 11, y + 8, 15, 0, hOutput); drawText("Ü", x + 27, y + 8, 8, 7, hOutput); drawText("Ü", x + 28, y + 8, 8, 4, hOutput); drawText("ÛÜÜÛ", x + 29, y + 8, 8, 0, hOutput); drawText("Ü", x + 33, y + 8, 8, 4, hOutput); drawText("Ü", x + 34, y + 8, 15, 4, hOutput); drawText("ßßßß", x + 35, y + 8, 15, 0, hOutput); drawText("ßßßÜ", x + 45, y + 8, 8, 0, hOutput); drawText("°", x + 57, y + 8, 8, 0, hOutput);
	drawText("  °±²Û    Û                                           Û²±°", x, y + 9, 7, 0, hOutput);
	drawText("°", x + 1, y + 9, 8, 0, hOutput); drawText("°", x + 11, y + 9, 6, 4, hOutput); drawText("Û", x + 12, y + 9, 15, 0, hOutput); drawText("°", x + 14, y + 9, 8, 0, hOutput); drawText("°", x + 15, y + 9, 4, 0, hOutput); drawText("°     Üß", x + 19, y + 9, 8, 0, hOutput); drawText("°", x + 27, y + 9, 4, 0, hOutput); drawText("°", x + 28, y + 9, 8, 0, hOutput); drawText("Üß", x + 32, y + 9, 15, 0, hOutput); drawText("°", x + 34, y + 9, 8, 0, hOutput); drawText("°", x + 36, y + 9, 4, 0, hOutput); drawText("°", x + 40, y + 9, 8, 0, hOutput); drawText("°   °", x + 41, y + 9, 4, 0, hOutput); drawText("Û", x + 48, y + 9, 8, 0, hOutput); drawText("ß", x + 49, y + 9, 8, 4, hOutput); drawText("Ü", x + 50, y + 9, 8, 0, hOutput); drawText("°", x + 58, y + 9, 8, 0, hOutput);
	drawText(" °±²Û   ÜÛ                                             Û²±°", x, y + 10, 7, 0, hOutput);
	drawText("°", x, y + 10, 8, 0, hOutput); drawText("Ü", x + 10, y + 10, 7, 4, hOutput); drawText("Ü", x + 11, y + 10, 7, 6, hOutput); drawText("Û", x + 12, y + 10, 15, 0, hOutput); drawText("°", x + 13, y + 10, 4, 0, hOutput); drawText("ÛßßßßÛßß ÜÜÜÜÜ", x + 17, y + 10, 8, 0, hOutput); drawText("Û", x + 31, y + 10, 15, 0, hOutput); drawText("ÜÜÜÜÜÜÜÜ    °", x + 32, y + 10, 8, 0, hOutput); drawText("°", x + 46, y + 10, 4, 0, hOutput); drawText("ÛÜ", x + 48, y + 10, 8, 6, hOutput); drawText("ÜÛ", x + 50, y + 10, 8, 4, hOutput); drawText("°", x + 59, y + 10, 8, 0, hOutput);
	drawText(" °±²Û            Û                    Ü                Û²±°", x, y + 11, 7, 0, hOutput);
	drawText("°", x, y + 11, 8, 0, hOutput); drawText("Û", x + 12, y + 11, 15, 0, hOutput); drawText("°", x + 15, y + 11, 4, 0, hOutput); drawText("Û°", x + 22, y + 11, 8, 0, hOutput); drawText("°", x + 25, y + 11, 4, 0, hOutput); drawText("Û", x + 26, y + 11, 8, 0, hOutput); drawText("ß", x + 39, y + 11, 8, 0, hOutput); drawText("°", x + 42, y + 11, 4, 0, hOutput); drawText("Üß", x + 46, y + 11, 8, 0, hOutput); drawText("°", x + 59, y + 11, 8, 0, hOutput);
	drawText("  °±²Û           ßßßß                ß                Û²±°", x, y + 12, 7, 0, hOutput);
	drawText("°", x + 1, y + 12, 8, 0, hOutput); drawText("Û", x + 12, y + 12, 15, 0, hOutput); drawText("°", x + 13, y + 12, 8, 0, hOutput); drawText("°", x + 14, y + 12, 4, 0, hOutput); drawText("ÛÛ", x + 21, y + 12, 8, 0, hOutput); drawText("°°±", x + 23, y + 12, 4, 0, hOutput); drawText("ßßßßßÜ", x + 26, y + 12, 8, 0, hOutput); drawText("Ü", x + 36, y + 12, 15, 0, hOutput); drawText("°", x + 39, y + 12, 4, 0, hOutput); drawText("°  Üß", x + 41, y + 12, 8, 0, hOutput); drawText("°", x + 58, y + 12, 8, 0, hOutput);
	drawText("   °±²Û                                              Û²±°", x, y + 13, 7, 0, hOutput);
	drawText("°", x + 2, y + 13, 8, 0, hOutput); drawText("Û", x + 12, y + 13, 15, 0, hOutput); drawText("°±°°°", x + 13, y + 13, 4, 0, hOutput); drawText("Üß Û", x + 19, y + 13, 8, 0, hOutput); drawText("±±²±°°", x + 23, y + 13, 4, 0, hOutput); drawText("°Û", x + 30, y + 13, 8, 0, hOutput); drawText("Ü", x + 34, y + 13, 15, 0, hOutput); drawText("ß", x + 35, y + 13, 15, 4, hOutput); drawText("°° °°", x + 36, y + 13, 4, 0, hOutput); drawText("Üß", x + 42, y + 13, 8, 0, hOutput); drawText("°", x + 57, y + 13, 8, 0, hOutput);
	drawText("    °±²Û    Û         Û                             Û²±°", x, y + 14, 7, 0, hOutput);
	drawText("°", x + 3, y + 14, 8, 0, hOutput); drawText("±²±±", x + 13, y + 14, 4, 0, hOutput); drawText("Ûß", x + 17, y + 14, 8, 0, hOutput); drawText("±²²", x + 23, y + 14, 4, 0, hOutput); drawText("Ûßßßßß", x + 26, y + 14, 8, 0, hOutput); drawText("Ü", x + 32, y + 14, 15, 0, hOutput); drawText("ß", x + 33, y + 14, 15, 4, hOutput); drawText("±±±°°°", x + 34, y + 14, 4, 0, hOutput); drawText("Üß", x + 40, y + 14, 8, 0, hOutput); drawText("°", x + 56, y + 14, 8, 0, hOutput);
	drawText("    °±²Û    Û         Û   ÛÜÜÜÜ                     Û²±°", x, y + 15, 7, 0, hOutput);
	drawText("°", x + 3, y + 15, 8, 0, hOutput); drawText("±²²±", x + 13, y + 15, 4, 0, hOutput); drawText("Û", x + 17, y + 15, 8, 0, hOutput); drawText("²²²", x + 23, y + 15, 4, 0, hOutput); drawText("Û", x + 31, y + 15, 15, 0, hOutput); drawText("²²²²±±±±", x + 32, y + 15, 4, 0, hOutput); drawText("ßßßßßßßßÛ", x + 40, y + 15, 8, 4, hOutput); drawText("°", x + 56, y + 15, 8, 0, hOutput);
	drawText("    °±²Û    Û         Û        Û                    Û²±°", x, y + 16, 7, 0, hOutput);
	drawText("°", x + 3, y + 16, 8, 0, hOutput); drawText("²²", x + 13, y + 16, 4, 0, hOutput); drawText("°", x + 15, y + 16, 6, 4, hOutput); drawText("²", x + 16, y + 16, 4, 0, hOutput); drawText("Û", x + 17, y + 16, 8, 0, hOutput); drawText("²", x + 23, y + 16, 4, 0, hOutput); drawText("±²±", x + 24, y + 16, 6, 4, hOutput); drawText("²²±±", x + 27, y + 16, 4, 0, hOutput); drawText("²²±", x + 32, y + 16, 6, 4, hOutput); drawText("²²²", x + 35, y + 16, 4, 0, hOutput); drawText("±°", x + 38, y + 16, 6, 4, hOutput); drawText("²²²", x + 40, y + 16, 4, 0, hOutput); drawText("°", x + 43, y + 16, 6, 4, hOutput); drawText("²²", x + 44, y + 16, 4, 0, hOutput); drawText("Ü", x + 46, y + 16, 8, 4, hOutput); drawText("ß", x + 47, y + 16, 8, 0, hOutput); drawText("°", x + 56, y + 16, 8, 0, hOutput);
	drawText("    °±²Û  ÜÛ          ß        ß                    Û²±°", x, y + 17, 7, 0, hOutput);
	drawText("°", x + 3, y + 17, 8, 0, hOutput); drawText("ÜÜÜ", x + 12, y + 17, 7, 4, hOutput); drawText("Ü", x + 15, y + 17, 8, 6, hOutput); drawText("ÜÜ", x + 16, y + 17, 8, 4, hOutput); drawText("ÛÜ", x + 17, y + 17, 8, 0, hOutput); drawText("Ü", x + 23, y + 17, 7, 4, hOutput); drawText("ÜÜÜ", x + 24, y + 17, 7, 6, hOutput); drawText("ÜÜÜÜ", x + 27, y + 17, 7, 4, hOutput); drawText("ÜÜÜ", x + 32, y + 17, 7, 6, hOutput); drawText("ÜÜÜ", x + 35, y + 17, 7, 4, hOutput); drawText("Ü", x + 38, y + 17, 7, 6, hOutput); drawText("Ü", x + 39, y + 17, 8, 6, hOutput); drawText("ÜÜÜ", x + 40, y + 17, 8, 4, hOutput); drawText("Ü", x + 43, y + 17, 8, 6, hOutput); drawText("Ü", x + 44, y + 17, 8, 4, hOutput); drawText("ß", x + 45, y + 17, 8, 0, hOutput); drawText("°", x + 56, y + 17, 8, 0, hOutput);
	drawText("     °±²                                            ²±°", x, y + 18, 7, 0, hOutput);
	drawText("°", x + 4, y + 18, 8, 0, hOutput); drawText("°", x + 55, y + 18, 8, 0, hOutput);
	drawText("      °±     sole   ild v1.0 [64-bit]               ±°", x, y + 19, 8, 0, hOutput);
	drawText("°", x + 5, y + 19, 8, 0, hOutput); drawText("Con", x + 10, y + 19, 8, 0, hOutput); drawText("Bu", x + 18, y + 19, 8, 0, hOutput); drawText("°", x + 54, y + 19, 8, 0, hOutput);
	drawText("       °        er guide type                       °", x, y + 20, 8, 0, hOutput);
	drawText("°", x + 6, y + 20, 8, 0, hOutput); drawText("For us", x + 10, y + 20, 8, 0, hOutput); drawText("HELP", x + 30, y + 20, 15, 0, hOutput); drawText(".", x + 34, y + 20, 8, 0, hOutput); drawText("°", x + 53, y + 20, 8, 0, hOutput);
	drawText("°", x + 7, y + 21, 8, 0, hOutput); drawText("°", x + 52, y + 21, 8, 0, hOutput);
}
void drawHelp(const short int x, short int &row,const char command[], const HANDLE hOutput,const CONSOLE_SCREEN_BUFFER_INFO bufferInfo)
{
	if (fromConsole) clearScreen(hOutput, bufferInfo);
	row++;
	if (!command[0])
	{
		drawText("FireFez 2021 [Console Build v1.0]", x, row, 8, 0, hOutput);
		drawText("Commands are not case-sensitive.", x, row + 2, 8, 0, hOutput);
		drawText("A pair of '\"'-s must be used for all space containing parameters.", x, row + 3, 8, 0, hOutput);
		drawText("When ran from console arguments and specifiers must be delimited by '_' instead of ' '.", x, row + 4, 8, 0, hOutput);
		drawText("For more information on a specific command, type HELP followed by the command.", x, row + 5, 8, 0, hOutput);
		drawText("For console error codes, type HELP ERROR.", x, row + 5, 8, 0, hOutput);
		drawText("   ---Commands---", x, row + 7, 8, 0, hOutput);
		drawText("CLEAR     Clears the screen.", x, row + 8, 8, 0, hOutput);
		drawText("DECRYPT   Decrypts a file with a given key.", x, row + 9, 8, 0, hOutput);
		drawText("EXIT      Quits FireFez.", x, row + 10, 8, 0, hOutput);
		drawText("ENCRYPT   Encrypts a file with a given key.", x, row + 11, 8, 0, hOutput);
		drawText("GETDIR    Returns the current working directory.", x, row + 12, 8, 0, hOutput);
		drawText("HELP      Provides Help information for FireFez 1.0 commands.", x, row + 13, 8, 0, hOutput);
		drawText("KEYGEN    Generates a new encryption key.", x, row + 14, 8, 0, hOutput);
		drawText("READ      Reads a file and dumps its contents on screen.", x, row + 15, 8, 0, hOutput);
		drawText("RENEW     Renews a key to the current version or restores it to a given version.", x, row + 15, 8, 0, hOutput);
		drawText("SETDIR    Changes the current working directory.", x, row + 16, 8, 0, hOutput);
		row += 17;
	}
	else if (!_strcmpi("clear", command))
	{
		drawText("Clears the screen.", x, row, 8, 0, hOutput);
		row += 1;
	}
	else if (!_strcmpi("decrypt", command))
	{
		drawText("Decrypts a file with a given key.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("DECRYPT [file_path] WITH [key_path] *AND *[password]", x + 8, row + 2, 15, 0, hOutput);
		drawText("(*) - optional", x, row + 3, 8, 0, hOutput);
		drawText("If the current working directory matches the file/key location then only the filename/keyname need to be passed.", x, row + 5, 8, 0, hOutput);
		drawText("Drag-and-drop a file in the console window to automatically copy its location and filename.", x, row + 6, 8, 0, hOutput);
		drawText("The AND specifier allows passing in a password. If the given file isn't a password protected file, an error message is returned.", x, row + 8, 8, 0, hOutput);
		drawText("If the given file is a password protected file, the user will be asked for a password.", x, row + 9, 8, 0, hOutput);
		drawText("The correctness of the password isn't verified. If a wrong password is passed in, the outputted decrypted file will be damaged.", x, row + 10, 8, 0, hOutput);
		row += 11;
	}
	else if (!_strcmpi("exit", command))
	{
		drawText("Quits FireFez.", x, row, 8, 0, hOutput);
		row += 1;
	}
	else if (!_strcmpi("encrypt", command))
	{
		drawText("Encrypts a file with a given key.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("ENCRYPT [file_path] WITH [key_path] *AND *[passowrd]", x + 8, row + 2, 15, 0, hOutput);
		drawText("(*) - optional", x, row + 3, 8, 0, hOutput);
		drawText("If the current working directory matches the file/key location then only the filename/keyname need to be passed.", x, row + 5, 8, 0, hOutput);
		drawText("Drag-and-drop a file in the console window to automatically copy its location and filename.", x, row + 6, 8, 0, hOutput);
		drawText("The AND specifier allows passing in a password that will overlay the given encryption key.", x, row + 8, 8, 0, hOutput);
		drawText("When decrypting a password protected file the user will be asked for the password unless it is passed as parameter.", x, row + 9, 8, 0, hOutput);
		drawText("A valid FireFez 1.0 password is 8-256 characters long and can contain any printable character, including spaces and excepting '\"'.", x, row + 10, 8, 0, hOutput);
		row += 11;
	}
	else if (!_strcmpi("getdir", command))
	{
		drawText("Returns the current working directory.", x, row, 8, 0, hOutput);
		row += 1;
	}
	else if (!_strcmpi("help", command))
	{
		drawText("Provides Help information for FireFez 1.0 commands.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("HELP *[command_name]", x + 8, row + 2, 15, 0, hOutput);
		drawText("(*) - optional", x, row + 3, 8, 0, hOutput);
		drawText("If no argument is passed the command will return a list of commands.", x, row + 5, 8, 0, hOutput);
		row += 6;
	}
	else if (!_strcmpi("keygen", command))
	{
		drawText("Generates a new encryption key.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("KEYGEN [file_name] *OVERWRITE", x + 8, row + 2, 15, 0, hOutput);
		drawText("(*) - optional", x, row + 3, 8, 0, hOutput);
		drawText("Existing files will not be overwritten unless the OVERWRITE specifier is passed.", x, row + 5, 8, 0, hOutput);
		row += 6;
	}
	else if (!_strcmpi("setdir", command))
	{
		drawText("Changes the current working directory.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("SETDIR [directory]", x + 8, row + 2, 15, 0, hOutput);
		drawText("An existing directory must be passed as argument.", x, row + 4, 8, 0, hOutput);
		row += 5;
	}
	else if (!_strcmpi("read", command))
	{
		drawText("Reads a file and dumps its contents on screen.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("READ [file_path] *AS *[CHR/INT]", x + 8, row + 2, 15, 0, hOutput);
		drawText("(*) - optional", x, row + 3, 8, 0, hOutput);
		drawText("If the current working directory matches the file/key location then only the filename/keyname need to be passed.", x, row + 5, 8, 0, hOutput);
		drawText("Drag-and-drop a file in the console window to automatically copy its location and filename.", x, row + 6, 8, 0, hOutput);
		drawText("The data is outputted in lines containing 64 elements.", x, row + 8, 8, 0, hOutput);
		drawText("The AS specifier allows setting a reading type: CHR(characters) or INT(integers).", x, row + 9, 8, 0, hOutput);
		drawText("The default type is CHR. Non-printable characters are replaced by '.' when CHR is used.", x, row + 10, 8, 0, hOutput);
		row += 11;
	}
	else if (!_strcmpi("renew", command))
	{
		drawText("Renews a key to the current version or restores it to a given version.", x, row, 8, 0, hOutput);
		drawText("Syntax:", x, row + 2, 8, 0, hOutput); drawText("RENEW [key_path] *TO *[4digit_value]", x + 8, row + 2, 15, 0, hOutput);
		drawText("(*) - optional", x, row + 3, 8, 0, hOutput);
		drawText("If the current working directory matches the file/key location then only the filename/keyname need to be passed.", x, row + 5, 8, 0, hOutput);
		drawText("Drag-and-drop a file in the console window to automatically copy its location and filename.", x, row + 6, 8, 0, hOutput);
		drawText("A pair of equivalent keys will remain equivalent after being renewed to the same value.", x, row + 8, 8, 0, hOutput);
		row += 9;
	}
	else if (!_strcmpi("error", command))
	{
		drawText("When ran from console the following error codes can be returned:", x, row, 8, 0, hOutput);
		drawText("Commands Interpretor:", x, row + 1, 15, 0, hOutput);
		drawText("#200 A NULL command was given.", x, row + 2, 8, 0, hOutput);
		drawText("#201 Quote was started but not ended, expecting '\"'.", x, row + 3, 8, 0, hOutput);
		drawText("#202 Unknown syntax.", x, row + 4, 8, 0, hOutput);

		drawText("DECRYPT:", x, row + 6, 15, 0, hOutput);
		drawText("#320 Argument list doesn't match the defined overloads.", x, row + 7, 8, 0, hOutput);
		drawText("#321 A specifier was expected(WITH).", x, row + 8, 8, 0, hOutput);
		drawText("#322 A specifier was expected(AND).", x, row + 9, 8, 0, hOutput);
		drawText("#323 Missing password.", x, row + 10, 8, 0, hOutput);
		drawText("#325 The file given could not be opened.", x, row + 11, 8, 0, hOutput);
		drawText("#326 The key given could not be opened.", x, row + 12, 8, 0, hOutput);
		drawText("#327 The file given is not a supported file.", x, row + 13, 8, 0, hOutput);
		drawText("#328 The file given is not a password protected file.", x, row + 14, 8, 0, hOutput);
		drawText("#329 The file given is not a FireFez 1.0 key or it is damaged.", x, row + 15, 8, 0, hOutput);
		drawText("#330 The key is not the original encryption key or it is damaged.", x, row + 16, 8, 0, hOutput);
		drawText("#331 The data stream was damaged.", x, row + 17, 8, 0, hOutput);

		drawText("ENCRYPT:", x, row + 19, 15, 0, hOutput);
		drawText("#300 Argument list doesn't match the defined overloads.", x, row + 20, 8, 0, hOutput);
		drawText("#301 A specifier was expected(WITH).", x, row + 21, 8, 0, hOutput);
		drawText("#302 A specifier was expected(AND).", x, row + 22, 8, 0, hOutput);
		drawText("#303 The password given was too short.", x, row + 23, 8, 0, hOutput);
		drawText("#304 The password given was too long.", x, row + 24, 8, 0, hOutput);
		drawText("#305 The file given could not be opened.", x, row + 25, 8, 0, hOutput);
		drawText("#306 The key given could not be opened.", x, row + 26, 8, 0, hOutput);
		drawText("#307 The file given is not a FireFez 1.0 key or it is damaged.", x, row + 27, 8, 0, hOutput);
		drawText("#308 The data stream was damaged.", x, row + 28, 8, 0, hOutput);
		drawText("#309 The file given is not a FireFez 1.0 supported file.", x, row + 29, 8, 0, hOutput);

		drawText("GETDIR:", x, row + 31, 15, 0, hOutput);
		drawText("#370 Argument list doesn't match the defined overloads.", x, row + 32, 8, 0, hOutput);
		drawText("#371 The current working directory could not be retrived.", x, row + 33, 8, 0, hOutput);

		drawText("HELP:", x, row + 35, 15, 0, hOutput);
		drawText("#399 The command given is not a defined FireFez 1.0 command.", x, row + 36, 8, 0, hOutput);

		drawText("KEYGEN:", x, row + 38, 15, 0, hOutput);
		drawText("#340 Argument list doesn't match the defined overloads.", x, row + 39, 8, 0, hOutput);
		drawText("#341 A specifier was expected(OVERWRITE).", x, row + 40, 8, 0, hOutput);
		drawText("#342 The name given was too long.", x, row + 41, 8, 0, hOutput);
		drawText("#343 The key could not be created.", x, row + 42, 8, 0, hOutput);
		drawText("#344 The key could not be opened.", x, row + 43, 8, 0, hOutput);
		drawText("#345 The key already exists.", x, row + 44, 8, 0, hOutput);

		drawText("READ:", x, row + 46, 15, 0, hOutput);
		drawText("#390 Argument list doesn't match the defined overloads.", x, row + 47, 8, 0, hOutput);
		drawText("#391 A specifier was expected(AS).", x, row + 48, 8, 0, hOutput);
		drawText("#392 A mode specifier was expected.", x, row + 49, 8, 0, hOutput);
		drawText("#393 The file given could not be opened.", x, row + 50, 8, 0, hOutput);

		drawText("RENEW:", x, row + 52, 15, 0, hOutput);
		drawText("#380 Argument list doesn't match the defined overloads.", x, row + 53, 8, 0, hOutput);
		drawText("#381 A specifier was expected(TO).", x, row + 54, 8, 0, hOutput);
		drawText("#386 The key given could not be opened.", x, row + 55, 8, 0, hOutput);
		drawText("#387 The key given is up to date.", x, row + 56, 8, 0, hOutput);
		drawText("#388 The value given is not 4 digits long.", x, row + 57, 8, 0, hOutput);
		drawText("#389 The file given is not a FireFez 1.0 key or it is damaged.", x, row + 58, 8, 0, hOutput);

		drawText("SETDIR:", x, row + 60, 15, 0, hOutput);
		drawText("#360 Argument list doesn't match the defined overloads.", x, row + 61, 8, 0, hOutput);
		drawText("#361 The given directory could not found.", x, row + 62, 8, 0, hOutput);

		row += 63;
	}
	else
	{
		if (fromConsole) cout << "Err#399\n";
		else
		{
			drawText("The command: \"", x, row, 8, 0, hOutput);
			drawText(command, x + 14, row, 4, 0, hOutput);
			drawText("\" is not a defined FreeFez 1.0 command.", x + 14 + strlen(command), row, 8, 0, hOutput);
		}
		row += 1;
	}
}

void reserveKeys(const int n)
{
	if (n == 0)
	{
		ofstream output("godmode.ffk", std::ios::binary);
		output.write(reserveKey[0], 524);
		output.close();
	}
	else if (n == 1)
	{
		ofstream output("jabota.ffk", std::ios::binary);
		output.write(reserveKey[1], 524);
		output.close();
	}
	else if (n == 2)
	{
		ofstream output("reserve.ffk", std::ios::binary);
		output.write(reserveKey[2], 524);
		output.close();
	}
	else if (n == 3)
	{
		ofstream output("UncleIsBack.ffk", std::ios::binary);
		output.write(reserveKey[3], 524);
		output.close();
	}
}

int generateKey(char filename[],const bool overwrite)
{
	if (strlen(filename) > 254) return 2;
	if (strrchr(filename, '.') == nullptr || strcmp(strrchr(filename, '.'), ".ffk")) strcat_s(filename, 260, ".ffk");

	ifstream input;
	input.open(filename);
	if (!input || overwrite)
	{
		ofstream output(filename, std::ios::binary);
		if (!output) return 3;
		//get date and formating
		int day, year; getDate(day, year);
		day += 100;
		char dat[4]; dat[0] = year % 10 + 37; dat[1] = day % 10 + 89; dat[2] = (day / 10) % 10 + 12; dat[3] = day / 100 + 42;
		output.write(dat, 4);

		//generating key
		char buff[520] = { 0 };
		int f[256] = { 0 };
		for (int i = 0; i < 520; i++)
			do
			{
				buff[i] = rand() % 255;
				f[buff[i] + 128]++;
			} while (buff[i] == i || f[buff[i] + 128] > 8);

		output.write(buff, 520);
		output.close();
		input.close();
		return 1;
	}
	else if (input)
	{
		input.close();
		return 0;
	}
}
int renewKey(const char keyname[],const int val)
{
	if (val < 1000 && val != -1) return 3;

	ifstream keyInput;
	keyInput.open(keyname, std::ios::binary);
	if (!keyInput) return 0;
	if (getFileSize(keyname) < 524 || strrchr(keyname, '.') == nullptr || strcmp(strrchr(keyname, '.'), ".ffk")) return 1;

	char dat[4];
	keyInput.read(dat, 4);
	const int kDay = dat[1] - 89 + (dat[2] - 12) * 10 + (dat[3] - 42) * 100 - 100, kYear = dat[0] - 37;

	int day, year;
	if (val == -1) { getDate(day, year); year %= 10; } //renew
	else { year = val / 1000; day = val % 1000 - 100; } //reset

	if ((day == kDay && year == kYear) || day==366) return 2; //same date, 366th day may fuck this

	char key[520];
	keyInput.read(key, 520);

	keyInput.close();

	//output date version
	ofstream keyOutput;
	keyOutput.open(keyname, std::ios::binary);
	dat[0] = year + 37; dat[1] = (day + 100) % 10 + 89; dat[2] = ((day + 100) / 10) % 10 + 12; dat[3] = (day + 100) / 100 + 42; //37, 89, 12, 42 - mask values
	keyOutput.write(dat, 4);

	const int dayCnt = (year - kYear) * 365 + day - kDay, dayStart = kYear * 365 + kDay;

	if (dayCnt > 0) //update
	{
		for (int i = 0; i < dayCnt; i++)
			for (int j = 0; j < 520; j++)
					key[j] += renewRule[((dayStart + i) * (j+1)) % 4][j];
	}
	else //rollback
	{
		for (int i = 0; i < -1*dayCnt; i++)
			for (int j = 0; j < 520; j++)
				key[j] -= renewRule[((dayStart - i - 1) * (j+1)) % 4][j];			
	}
	
	keyOutput.write(key, 520);
	keyOutput.close();
	return 4;
}
int encrypt(char filename[],const char keyname[], const char password[],const short int row,const HANDLE hOutput)
{
	ifstream fileInput, keyInput;
	fileInput.open(filename, std::ios::binary);
	keyInput.open(keyname, std::ios::binary);
	if (!fileInput) return 0;
	if (!keyInput) return 1;

	if (getFileSize(keyname) < 524 || strrchr(keyname, '.') == nullptr || strcmp(strrchr(keyname, '.'), ".ffk")) return 3;

	if (strrchr(filename, '.') == nullptr || strlen(strrchr(filename, '.')) != 4) return 5;

	if(!fromConsole) drawText("Work in progress, please wait...", 0, row + 1, 8, 0, hOutput);

	const unsigned long long int fileSize = getFileSize(filename);
	unsigned long long int procBytes = 0, percentage = 0;
	const int digSize = digitCnt(fileSize);
	int resProcBytes = 0;


	//get name and extension of filename
	char ext[261], name[261];
	strcpy_s(ext, 260, strrchr(filename, '.'));
	strncpy_s(name, 260, filename, strlen(filename) - strlen(strrchr(filename, '.')));
	strcat_s(name, 260, ".fez\0");
	
	strcpy_s(filename, 260, name);

	ofstream fileOutput;
	fileOutput.open(name, std::ios::binary);

	char buff[256] = { 0 }, key[512], extKey[8];
	keyInput.seekg(4, ios::beg); // skip date line
	keyInput.read(extKey, 8);
	keyInput.read(key, 512);
	keyInput.close();

	//encrypting and adding extension
	for (int i = 0; i < 4; i++)
		ext[i] += extKey[i] - extKey[i + 4];
	fileOutput.write(ext, 4);

	const int passLen = strlen(password);
	if (passLen > 1)
	{
		const int pSum = charSum(password, 0, passLen, sizeof password);
		for (int i = 0; i < 512; i++)
			key[i] += pSum - password[i%passLen];
		const char cExt[1] = { extKey[1] + extKey[4] + extKey[7] + 's' };
		fileOutput.write(cExt, 1);
	}
	else { const char cExt[1] = { extKey[1] + extKey[4] + extKey[7] + 'v' }; fileOutput.write(cExt, 1); }

	const int parseNo = (85427 * (charSum(key, 0, 512, sizeof key) + 65752)) % 128; //selecting a parsing rule

	memset(buff, 0, 256);
	fileInput.read(buff, 256);
	int bitCount = static_cast<int>(fileInput.gcount());
	
	//hidding cursor
	CONSOLE_CURSOR_INFO cursorInfo;
	if (!fromConsole)
	{
		GetConsoleCursorInfo(hOutput, &cursorInfo);
		cursorInfo.bVisible = false;
		SetConsoleCursorInfo(hOutput, &cursorInfo);
	}

	while (bitCount)
	{
		if (!fromConsole)
		{
			if (resProcBytes == 262144)
			{
				percentage = (procBytes * 100) / fileSize;
				const int digProc = digitCnt(procBytes);
				drawInt(procBytes, 34, row + 1, 10, 0, hOutput); drawText("/", 34 + digProc, row + 1, 8, 0, hOutput); drawInt(fileSize, 35 + digProc, row + 1, 15, 0, hOutput); drawText("bytes           ", 35 + digProc + digSize, row + 1, 8, 0, hOutput);
				drawInt(percentage, 43 + digProc + digSize, row + 1, 10, 0, hOutput); drawText("%", 43 + digProc + digSize + digitCnt(percentage), row + 1, 15, 0, hOutput);
				resProcBytes = 0;
			}
			resProcBytes += bitCount;
		}
		procBytes += bitCount;

		int iStart = 0;
		for (int parseI = 0; parseI < 17; parseI++)
		{
			const int keySum = charSum(key, iStart, 256, sizeof key);
			for (int i = 0; i < bitCount; i++)
			{
				buff[i] += keySum - key[i + iStart];
				buff[(key[i + iStart] + 128) % bitCount] += keySum - key[511 - i - iStart];
				swap(buff[i], buff[(key[i + iStart] + 128) % bitCount]);
			}
			if (parseI < 16) iStart += parseRule[parseNo][parseI];
		}
		fileOutput.write(buff, bitCount);
		memset(buff, 0, 256);
		fileInput.read(buff, 256);
		bitCount = static_cast<int>(fileInput.gcount());
	}

	if (!fromConsole)
	{
		cursorInfo.bVisible = true;
		SetConsoleCursorInfo(hOutput, &cursorInfo);
	}

	fileInput.close();
	fileOutput.close();

	if (procBytes < fileSize) return 4;

	return 2;
}
int decrypt(char filename[], const char keyname[], char password[], const short int row,const HANDLE hOutput)
{
	ifstream fileInput, keyInput;
	fileInput.open(filename, std::ios::binary);
	keyInput.open(keyname, std::ios::binary);
	if (!fileInput) return 0;
	if (!keyInput) return 1;

	if (strrchr(filename, '.') == nullptr || strcmp(strrchr(filename, '.'), ".fez")) return 2;

	if (getFileSize(keyname) < 524 || strrchr(keyname, '.') == nullptr || strcmp(strrchr(keyname, '.'), ".ffk")) return 5;

	//getting the extension and passtype
	char ext[261] = { 0 }, buff[256] = { 0 }, key[512], name[261] = { 0 }, ps[1], extKey[8];
	fileInput.read(ext, 4);
	fileInput.read(ps, 1);


	keyInput.seekg(4, ios::beg); // skip date line
	keyInput.read(extKey, 8);
	keyInput.read(key, 512);
	keyInput.close();

	//decrypting extension and ps
	for (int i = 0; i < 4; i++)
		ext[i] -= extKey[i] - extKey[i + 4];
	ps[0] -= extKey[1] + extKey[4] + extKey[7];

	if (ext[0] != '.') return 6; //wrong key or damaged

	int i, passLen;

	if (ps[0] == 's') //password
	{
		if (strlen(password) < 1 && fromConsole) return 8;
		if (strlen(password) < 1)
		{
			drawText("Please enter password: ", 0, row + 1, 8, 0, hOutput);
			//getting invisible password
			int k = 0; char c;
			c = _getch();
			while (c != 13 && k < 254)
			{
				if (c == 8)
				{
					if (k > 0) k--, password[k] = 0;
				}
				else if (c >= 32 && c <= 126 && c != 34)
				{
					password[k] = c;
					k++;
				}
				c = _getch();
			}
			password[k] = 0;
		}
		passLen = strlen(password);
		const int pSum = charSum(password, 0, passLen, sizeof password);
		for (i = 0; i < 512; i++)
			key[i] += pSum - password[i%passLen];
	}
	else if (strlen(password) > 0) return 4;

	if (!fromConsole) drawText("Work in progress, please wait...", 0, row + 1, 8, 0, hOutput);

	const unsigned long long int fileSize = getFileSize(filename) - 5;
	unsigned long long int procBytes = 0, percentage = 0;
	const int digSize = digitCnt(fileSize);

	//build output name
	strncpy_s(name, 260, filename, strlen(filename) - strlen(strrchr(filename, '.')));
	strcat_s(name, 260, ext);

	strcpy_s(filename, 260, name);

	ofstream fileOutput;
	fileOutput.open(name, std::ios::binary);

	int parseI; const int parseNo = (85427 * (charSum(key, 0, 512, sizeof key) + 65752)) % 128; //selecting a parsing rule

	//hiding cursor
	CONSOLE_CURSOR_INFO cursorInfo;
	if (!fromConsole)
	{
		GetConsoleCursorInfo(hOutput, &cursorInfo);
		cursorInfo.bVisible = false;
		SetConsoleCursorInfo(hOutput, &cursorInfo);
	}

	memset(buff, 0, 256);
	fileInput.read(buff, 256);
	int bitCount = static_cast<int>(fileInput.gcount());

	while (bitCount)
	{
		if (!fromConsole)
		{
			if (procBytes % 262144 == 0)
			{
				percentage = (procBytes * 100) / fileSize;
				const int digProc = digitCnt(procBytes);
				drawInt(procBytes, 34, row + 1, 10, 0, hOutput); drawText("/", 34 + digProc, row + 1, 8, 0, hOutput); drawInt(fileSize, 35 + digProc, row + 1, 15, 0, hOutput); drawText("bytes           ", 35 + digProc + digSize, row + 1, 8, 0, hOutput);
				drawInt(percentage, 43 + digProc + digSize, row + 1, 10, 0, hOutput); drawText("%", 43 + digProc + digSize + digitCnt(percentage), row + 1, 15, 0, hOutput);
			}
		}
		procBytes += bitCount;

		int iStart = 256;
		for (parseI = 15; parseI >= -1; parseI--)
		{
			const int keySum = charSum(key, iStart, 256, sizeof key);
			for (i = bitCount - 1; i >= 0; i--)
			{
				swap(buff[i], buff[(key[i + iStart] + 128) % bitCount]);
				buff[i] -= keySum - key[i + iStart];
				buff[(key[i + iStart] + 128) % bitCount] -= keySum - key[511 - i - iStart];
			}
			if (parseI >= 0) iStart -= parseRule[parseNo][parseI];
		}
		fileOutput.write(buff, bitCount);
		memset(buff, 0, 256);
		fileInput.read(buff, 256);
		bitCount = static_cast<int>(fileInput.gcount());
	}

	if (!fromConsole)
	{
		cursorInfo.bVisible = true;
		SetConsoleCursorInfo(hOutput, &cursorInfo);
	}

	fileInput.close();
	fileOutput.close();

	if (procBytes < fileSize) return 7;

	return 3;
}
int readFile(const char filename[], const int mode, short int &row,const HANDLE hOutput)
{
	//file check
	ifstream fileInput;
	fileInput.open(filename, std::ios::binary);
	if (!fileInput) return 0;

	int j = 1, bitCount; unsigned long long int fSize = 0; //size of file
	row++;
	char buff[64] = { 0 };
	fileInput.read(buff, 64);
	bitCount = static_cast<int>(fileInput.gcount());

	while (bitCount)
	{
		fSize += bitCount;

		SetConsoleTextAttribute(hOutput, 8);

		//unsigned cast for isprint
		unsigned char uBuff[64] = { 0 };
		memcpy(uBuff, buff, bitCount);

		if(!fromConsole) cout << j << ". ";
		for (int i = 0; i < bitCount; i++) //dumping data
		{
			if (mode == 1) //char
			{
				if (isprint(static_cast<int>(uBuff[i])))
				{
					if (!fromConsole) SetConsoleTextAttribute(hOutput, 15);
					cout << buff[i];
				}
				else
				{
					if (!fromConsole)
						SetConsoleTextAttribute(hOutput, 8);
					cout << '.';
				}
			}
			else if (mode == 2) //int
			{
				if (!fromConsole)
					SetConsoleTextAttribute(hOutput, 15), cout << std::setw(4);
				cout << static_cast<int>(buff[i]) << ' ';
			}
			
		}
		cout << '\n';
		row++;
		j++;
		memset(buff, 0, 64);
		memset(uBuff, 0, 64);
		fileInput.read(buff, 64);
		bitCount = static_cast<int>(fileInput.gcount());
	}
	SetConsoleTextAttribute(hOutput, 15);
	row+=1;

	if (!fromConsole)
	{
		drawText("File read successfully.", 0, row + 1, 8, 0, hOutput);
		drawInt(fSize, 24, row + 1, 10, 0, hOutput);
		drawText("bytes were dumped on screen as ", 25 + digitCnt(fSize), row + 1, 8, 0, hOutput);
		if (mode == 1) drawText("characters", 56 + digitCnt(fSize), row + 1, 10, 0, hOutput), drawText(".", 66 + digitCnt(fSize), row + 1, 8, 0, hOutput);
		else if (mode == 2) drawText("integers", 56 + digitCnt(fSize), row + 1, 10, 0, hOutput), drawText(".", 64 + digitCnt(fSize), row + 1, 8, 0, hOutput);
	}

	fileInput.close();

	return 1;
}

int consoleMain(const int argc, char *argv[],const HANDLE hOutput, const CONSOLE_SCREEN_BUFFER_INFO bufferInfo)
{
	char commands[10][261];
	short int row = 1;

	for (int argi = 1; argi < argc && _strcmpi("exit", argv[argi]); argi++)
	{
		//empty command parameter list
		int i, j = 0, k = 0;
		for (i = 0; i < 10; i++)
			memset(commands[i], 0, 261);

		//parsing the line
		i = 0;
		bool inName = false;
		while (argv[argi][i] && j < 10)
		{
			if (!inName)
			{
				if (argv[argi][i] == '\"') inName = true;

				else if (argv[argi][i] != '_') commands[j][k] = argv[argi][i], k++;
				else
				{
					if (commands[j][0]) j++;
					k = 0;
				}
			}
			else
			{
				if (argv[argi][i] == '\"') inName = false;
				else
				{
					commands[j][k] = argv[argi][i];
					k++;
				}
			}
			i++;
		}

		//interpreting
		if (inName)
		{
			cout << "Err#201\n";
			row += 2;
		}
		else if (!_strcmpi("encrypt", commands[0]))
		{
			if (commands[1][0] == 0 || commands[2][0] == 0 || commands[3][0] == 0 || (commands[4][0] != 0 && commands[5][0] == 0) || commands[6][0] != 0)
				cout << "Err#300\n";
			else if (commands[2][0] != 0 && _strcmpi("with", commands[2])) cout << "Err#301\n";
			else if (commands[4][0] != 0 && _strcmpi("and", commands[4])) cout << "Err#302\n";
			else if (commands[4][0] != 0 && strlen(commands[5]) < 8) cout << "Err#303\n";	
			else if (commands[4][0] != 0 && strlen(commands[5]) > 256) cout << "Err#304\n";
			else
			{
				int error;
				error = encrypt(commands[1], commands[3], commands[5], row, hOutput);
				if (error == 2) cout << "Success\n";
				else if (error == 0) cout << "Err#305\n";
				else if (error == 1) cout << "Err#306\n";
				else if (error == 3) cout << "Err#307\n";
				else if (error == 4) cout << "Err#308\n";
				else if (error == 5) cout << "Err#309\n";
			}
			row += 2;
		}
		else if (!_strcmpi("decrypt", commands[0]))
		{
			if (commands[1][0] == 0 || commands[2][0] == 0 || commands[3][0] == 0 || (commands[4][0] != 0 && commands[5][0] == 0) || commands[6][0] != 0)
				cout << "Err#320\n";
			else if (commands[2][0] != 0 && _strcmpi("with", commands[2])) cout << "Err#321\n";
			else if (commands[4][0] != 0 && _strcmpi("and", commands[4])) cout << "Err#322\n";
			else
			{
				int error;
				error = decrypt(commands[1], commands[3], commands[5], row, hOutput);
				if (error == 3) cout << "Success\n";
				else if (error == 0) cout << "Err#325\n";
				else if (error == 1) cout << "Err#326\n";
				else if (error == 2) cout << "Err#327\n";
				else if (error == 4) cout << "Err#328\n";
				else if (error == 5) cout << "Err#329\n";
				else if (error == 6) cout << "Err#330\n";
				else if (error == 7) cout << "Err#331\n";
				else if (error == 8) cout << "Err#323\n"; //console only
			}
			row += 2;
		}
		else if (!_strcmpi("keygen", commands[0])) //KEYGEN
		{
			if (commands[1][0] == 0 || commands[3][0] != 0) cout << "Err#340\n";
			else if (commands[2][0] != 0 && _strcmpi("overwrite", commands[2])) cout << "Err#341\n";
			else if (commands[2][0] == 0) //NO overwrite
			{
				int error = generateKey(commands[1], false);
				if (error == 1) cout << "Success\n";
				else if (error == 0) cout << "Err#345\n";
				else if (error == 2) cout << "Err#342\n";
				else if (error == 3) cout << "Err#343\n";
			}
			else if (!_strcmpi("overwrite", commands[2])) //OVERWRITE
			{
				int error = generateKey(commands[1], true);
				if (error == 1) cout << "Success\n";
				else if (error == 3) cout << "Err#334\n";
			}
			row += 2;
		}
		else if (!_strcmpi("setdir", commands[0]))
		{
			if (commands[1][0] == 0 || commands[2][0] != 0) cout << "Err#360\n";
			else
			{
				if (!_chdir(commands[1])) cout << "Success\n";
				else cout << "Err#361\n";
			}
			row += 2;
		}
		else if (!_strcmpi("getdir", commands[0]))
		{
			if (commands[1][0] != 0) cout << "Err#370\n";
			else
			{
				char location[261];
				if (_getcwd(location, 260) && location[0])
					cout << location << '\n';
				else cout << "Err#371\n";
			}
			row += 2;
		}
		else if (!_strcmpi("renew", commands[0]))
		{
			if (commands[1][0] == 0 || (commands[2][0] != 0 && commands[3][0] == 0) || commands[4][0] != 0)
				cout << "Err#380\n";
			else if (commands[2][0] != 0 && _strcmpi("to", commands[2])) cout << "Err#381\n";
			else
			{
				int error;
				if (commands[3][0])
				{
					if (strlen(commands[3]) != 4)
						error = 3;
					else
					{
						int val = (commands[3][0] - 37) * 1000 + (commands[3][1] - 89) * 100 + (commands[3][2] - 12) * 10 + (commands[3][3] - 42);
						error = renewKey(commands[1], val);
					}
				}
				else error = renewKey(commands[1], -1);

				if (error == 4) cout << "Success\n";
				else if (error == 0) cout << "Err#386\n";
				else if (error == 1) cout << "Err#389\n";
				else if (error == 2) cout << "Err#387\n";
				else if (error == 3) cout << "Err#388\n";
			}
			row += 2;
		}
		else if (!_strcmpi("read", commands[0]))
		{
			if (commands[1][0] == 0 || (commands[2][0] != 0 && commands[3][0] == 0) || commands[4][0] != 0)
				cout << "Err#390\n";
			else if (commands[2][0] != 0 && _strcmpi("as", commands[2])) cout << "Err#391\n";
			else if (commands[3][0] != 0 && (_strcmpi("chr", commands[3]) && _strcmpi("int", commands[3]))) cout << "Err#392\n";
			else
			{
				int mode = 1;
				if (commands[3][0] == 0 || !_strcmpi("chr", commands[3])) mode = 1; //char, default
				else if (!_strcmpi("int", commands[3])) mode = 2; //int

				int error = readFile(commands[1], mode, row, hOutput);
				if (error == 0) cout << "Err#393\n";
			}
			row += 2;
		}
		else if (!_strcmpi("clear", commands[0])) clearScreen(hOutput, bufferInfo), row = 0;
		else if (!_strcmpi("help", commands[0])) drawHelp(0, row, commands[1], hOutput, bufferInfo);
		else if (!_strcmpi("exit", commands[0])) return 0;
		else if (argv[argi][0])
		{
		cout << "Err#202\n";
			row += 2;
		}
		else cout << "Err#200\n", row+=2;

		if (row > 9000) clearScreen(hOutput, bufferInfo), row = 0;
	}
	return 0;
}

int main(int argc, char *argv[])
{
	HWND cHwnd = GetConsoleWindow();
	HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	//HANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);
	//HDC cHdc = GetDC(cHwnd);
	CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
	GetConsoleScreenBufferInfo(hOutput, &bufferInfo);

	//seeding rng
	srand(static_cast<unsigned int>(time(nullptr)));
	srand(rand());

	//check if run from console
	DWORD dwProcessId;
	GetWindowThreadProcessId(cHwnd, &dwProcessId);
	if (GetCurrentProcessId() != dwProcessId && argc > 1 && argv[1][0])
	{
		fromConsole = true;
		return consoleMain(argc, argv, hOutput, bufferInfo);
	}

	char cInput[625] = { 0 };
	clearScreen(hOutput, bufferInfo);
	startup(cHwnd, hOutput, bufferInfo);
	drawTitle(29, 0, hOutput);

	drawText("___________________________________________________________________________________________________________________", 0, 22, 8, 0, hOutput);

	char commands[10][261];
	short int row = 24;

	while (_strcmpi("exit", cInput)) 
	{
		//console input interface
		//setCursorPos(0, row);
		drawText("<> ", 0, row, 15, 0, hOutput);
		cin.getline(cInput, 624);
		cout << '\n';


		//empty command parameter list
		int i, j = 0, k = 0;
		for (i = 0; i < 10; i++)
			memset(commands[i], 0, 261);

		//parsing the line
		i = 0;
		bool inName = false;
		while (cInput[i] && j<10)
		{
			if (!inName)
			{
				if (cInput[i] == '\"') inName = true;

				else if (cInput[i] != ' ') commands[j][k] = cInput[i], k++;
				else
				{
					if(commands[j][0]) j++;
					k = 0;
				}
			}
			else
			{
				if (cInput[i] == '\"') inName = false;
				else
				{
					commands[j][k] = cInput[i];
					k++;
				}
			}
			i++;
		}
		//interpreting
		if (inName)
		{
			drawText("Warning: A quote was started but not ended. Expecting a '", 0, row + 1, 8, 0, hOutput);
			drawText("\"", 57, row + 1, 4, 0, hOutput);
			drawText("'.", 58, row + 1, 8, 0, hOutput);
			row += 2;
		}
		else if (!_strcmpi("encrypt", commands[0]))
		{
			if (commands[1][0] == 0 || commands[2][0] == 0 || commands[3][0] == 0 || (commands[4][0] != 0 && commands[5][0] == 0) || commands[6][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else if (commands[2][0] != 0 && _strcmpi("with", commands[2]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[2], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[2]), row + 1, 8, 0, hOutput);
			}
			else if (commands[4][0] != 0 && _strcmpi("and", commands[4]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[4], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[4]), row + 1, 8, 0, hOutput);
			}
			else if (commands[4][0] != 0 && commands[5][7] == 0)
			{
				drawText("Warning: FireFez 1.0 passwords must be at least 8 characters long. The password given is too short.", 0, row + 1, 8, 0, hOutput);
			}
			else if (commands[4][0] != 0 && strlen(commands[5]) > 256)
			{
				drawText("Warning: The maximum FireFez 1.0 password lenght of 256 was exceeded. The password given is too long.", 0, row + 1, 8, 0, hOutput);
			}
			else
			{
				int error;
				error= encrypt(commands[1], commands[3], commands[5], row, hOutput);
				if(error == 2) //success
				{
					drawText("File encrypted successfully and dumped into: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 46, row + 1, 10, 0, hOutput);
					drawText("\".                 ", 46 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 0) //bad filename
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 1) //bad keyname
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[3], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[3]), row + 1, 8, 0, hOutput);
				}
				else if (error == 3) //bad key
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[3], 11, row + 1, 4, 0, hOutput);
					drawText("\" is not a FireFez 1.0 key or it is damaged.", 11 + strlen(commands[3]), row + 1, 8, 0, hOutput);
				}
				else if (error == 4) //stream damaged
				{
					drawText("Some bytes from the original file are missing, the data stream may have been damaged.", 0, row + 1, 8, 0, hOutput);
				}
				else if (error == 5) //bad filename
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" is not a supported file.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("decrypt", commands[0]))
		{
			if (commands[1][0] == 0 || commands[2][0] == 0 || commands[3][0] == 0 || (commands[4][0] != 0 && commands[5][0] == 0) || commands[6][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else if (commands[2][0] != 0 && _strcmpi("with", commands[2]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[2], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[2]), row + 1, 8, 0, hOutput);
			}
			else if (commands[4][0] != 0 && _strcmpi("and", commands[4]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[4], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[4]), row + 1, 8, 0, hOutput);
			}
			else
			{
				int error;
				error = decrypt(commands[1], commands[3], commands[5], row, hOutput);
				if (error == 3)
				{
					drawText("File decrypted successfully and dumped into: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 46, row + 1, 10, 0, hOutput);
					drawText("\".            ", 46 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 0)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 1)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[3], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[3]), row + 1, 8, 0, hOutput);
				}
				else if (error == 2) //not .fez
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" does not match the supported format.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 4)
				{
					drawText("File given isn't a password protected file.", 0, row + 1, 8, 0, hOutput);
				}
				else if (error == 5) //bad key
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[3], 11, row + 1, 4, 0, hOutput);
					drawText("\" is not a FireFez 1.0 key or it is damaged.", 11 + strlen(commands[3]), row + 1, 8, 0, hOutput);
				}
				else if (error == 6) //wrong key or damage
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could be damaged or the key: \"", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
					drawText(commands[3], 43 + strlen(commands[1]), row + 1, 4, 0, hOutput);
					drawText("\" could not be the original encryption key.", 43 + strlen(commands[1]) + strlen(commands[3]), row + 1, 8, 0, hOutput);
				}
				else if (error == 7) //stream damaged
				{
					drawText("Some bytes from the original file are missing, the data stream may have been damaged.", 0, row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("keygen", commands[0])) //KEYGEN
		{
			if (commands[1][0] == 0 || commands[3][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else if (commands[2][0] != 0 && _strcmpi("overwrite", commands[2]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[2], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[2]), row + 1, 8, 0, hOutput);
			}
			else if (commands[2][0] == 0) //NO overwrite
			{
				int error = generateKey(commands[1], false);
				if (error == 1)
				{
					drawText("Key generated successfully and dumped into: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 45, row + 1, 10, 0, hOutput);
					drawText("\".", 45 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 0)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" already exists, to overwrite it use the specifier OVERWRITE.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 2)
				{
					drawText("The filename: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 15, row + 1, 4, 0, hOutput);
					drawText("\" is too long. Key extension could not be added.", 15 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 3)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be created.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
			}
			else if (!_strcmpi("overwrite", commands[2])) //OVERWRITE
			{
				int error = generateKey(commands[1], true);
				if (error == 1)
				{
					drawText("Key generated successfully and dumped into: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 45, row + 1, 10, 0, hOutput);
					drawText("\".", 45 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 3)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("setdir", commands[0]))
		{
			if (commands[1][0] == 0 || commands[2][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else
			{
				if (!_chdir(commands[1]))
				{
					drawText("The current working directory was set to: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 43, row + 1, 10, 0, hOutput);
					drawText("\".", 43 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else
				{
					drawText("The given directory: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 22, row + 1, 4, 0, hOutput);
					drawText("\" could not be found.", 22 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("getdir", commands[0]))
		{
			if (commands[1][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else
			{
				char location[261];
				if (_getcwd(location, 260) && location[0])
				{
					drawText("The current working directory is: \"", 0, row + 1, 8, 0, hOutput);
					drawText(location, 35, row + 1, 10, 0, hOutput);
					drawText("\".", 35 + strlen(location), row + 1, 8, 0, hOutput);
				}
				else
				{
					drawText("The current working directory could not be retrived.", 0, row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("renew", commands[0]))
		{
			if (commands[1][0] == 0 || (commands[2][0] != 0 && commands[3][0] == 0) || commands[4][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else if (commands[2][0] != 0 && _strcmpi("to", commands[2]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[2], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[2]), row + 1, 8, 0, hOutput);
			}
			else
			{
				int error;
				if (commands[3][0])
				{
					if (strlen(commands[3]) != 4)
						error = 3;
					else
					{
						int val = (commands[3][0] - 37) * 1000 + (commands[3][1] - 89) * 100 + (commands[3][2] - 12) * 10 + (commands[3][3] - 42);
						error = renewKey(commands[1], val);
					}
				}
				else error = renewKey(commands[1], -1);

				if (error == 4)//success
				{
					if (commands[3][0])
					{
						drawText("Key restored to ", 0, row + 1, 8, 0, hOutput);
						drawText(commands[3], 16, row + 1, 10, 0, hOutput);
						drawText(" and dumped into: \"", 20, row + 1, 8, 0, hOutput);
						drawText(commands[1], 39, row + 1, 10, 0, hOutput);
						drawText("\".", 39 + strlen(commands[1]), row + 1, 8, 0, hOutput);
					}
					else
					{
						drawText("Key renewed successfully and dumped into: \"", 0, row + 1, 8, 0, hOutput);
						drawText(commands[1], 43, row + 1, 10, 0, hOutput);
						drawText("\".", 43 + strlen(commands[1]), row + 1, 8, 0, hOutput);
					}
				}
				else if (error == 0)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 1)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" is not a FireFez 1.0 key or it is damaged.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 2)
				{
					drawText("The key: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 10, row + 1, 4, 0, hOutput);
					drawText("\" is up to date. Keys can only be renewed once a day.", 10 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
				else if (error == 3)
				{
					drawText("The value: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[3], 12, row + 1, 4, 0, hOutput);
					drawText("\" must be exactly 4 digits long.", 12 + strlen(commands[3]), row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("read", commands[0]))
		{
			if (commands[1][0] == 0 || (commands[2][0] != 0 && commands[3][0] == 0) || commands[4][0] != 0)
			{
				drawText("Incorrect syntax: Argument list doesn't match the defined overloads.", 0, row + 1, 8, 0, hOutput);
			}
			else if (commands[2][0] != 0 && _strcmpi("as", commands[2]))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[2], 19, row + 1, 4, 0, hOutput);
				drawText("\". A specifier was expected.", 19 + strlen(commands[2]), row + 1, 8, 0, hOutput);
			}
			else if (commands[3][0] != 0 && (_strcmpi("chr", commands[3]) && _strcmpi("int", commands[3])))
			{
				drawText("Incorrect syntax: \"", 0, row + 1, 8, 0, hOutput);
				drawText(commands[3], 19, row + 1, 4, 0, hOutput);
				drawText("\". A mode specifier was expected.", 19 + strlen(commands[3]), row + 1, 8, 0, hOutput);
			}
			else
			{
				int mode = 1;
				if (commands[3][0] == 0 || !_strcmpi("chr", commands[3])) mode = 1; //char, default
				else if (!_strcmpi("int", commands[3])) mode = 2; //int

				int error = readFile(commands[1], mode, row, hOutput);
				if (error == 0)
				{
					drawText("The file: \"", 0, row + 1, 8, 0, hOutput);
					drawText(commands[1], 11, row + 1, 4, 0, hOutput);
					drawText("\" could not be opened.", 11 + strlen(commands[1]), row + 1, 8, 0, hOutput);
				}
			}
			row += 2;
		}
		else if (!_strcmpi("clear", commands[0])) clearScreen(hOutput, bufferInfo), row = 0;
		else if (!_strcmpi("help", commands[0])) drawHelp(0, row, commands[1], hOutput, bufferInfo);
		else if (!_strcmpi("exit", commands[0])) return 0;
		else if (!strcmp(hidstr[0], commands[0])) reserveKeys(0), row++;
		else if (!strcmp(hidstr[1], commands[0])) reserveKeys(1), row++;
		else if (!strcmp(hidstr[2], commands[0])) reserveKeys(2), row++;
		else if (!strcmp(hidstr[3], commands[0])) reserveKeys(3), row++;
		else if (cInput[0])
		{
			drawText("Unknown syntax: \"", 0, row + 1, 8, 0, hOutput);
			drawText(cInput, 17, row + 1, 4, 0, hOutput);
			drawText("\". Type HELP for command list.", 17 + strlen(cInput), row + 1, 8, 0, hOutput);
			row += 2;
		}
		else row++;

		if (row > 9000) clearScreen(hOutput, bufferInfo), row = 0;
	}
	return 0;
}